<?xml version="1.0" encoding="UTF-8"?><?xml-model href="http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?><?xml-model href="http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?><article xmlns="http://docbook.org/ns/docbook" xml:id="paper-25" version="5.0" xml:lang="en">
    <info xmlns:xl="http://www.w3.org/1999/xlink">
        <title>Streaming Design Patterns or: How I Learned to Stop Worrying and Love the Stream</title>
        <author>
          <personname>
            <firstname>Abel</firstname>
            <surname>Braaksma</surname>
          </personname>
          <affiliation>
            <jobtitle>owner</jobtitle>
            <orgname>Abrasoft</orgname>
          </affiliation>
          <affiliation>
            <jobtitle>creator/owner</jobtitle>
            <orgname>Exselt XSLT 3.0 streaming processor</orgname>
          </affiliation>
          <email>abel@exselt.net</email>
          <personblurb>
              <para>Abel Braaksma is owner of <link xl:href="http://exselt.net">Exselt</link> and
                  the consultancy and outsourcing firm <link xl:href="http://abrasoft.net">Abrasoft</link>. He designed and created the new streaming XSLT 3.0
                  processor Exselt together with other developers. He has more than 15 years
                  experience with XML and related technologies and is currently an Invited Expert
                  of the XSLT and XPath working groups at W3C. He can be contacted about anything
                  related to XML, XSLT, C#, Java or F# through at <link xl:href="mailto:info@abrasoft.net;">info@abrasoft.net;</link> specific
                  inquiries on the Exselt processor can be send to <link xl:href="mailto:info@exselt.net">info@exselt.net</link>. For his musings on
                  technologies in general, you can visit <link xl:href="http://undermyhat.org">his
                      blog Under My Hat</link>.</para>
          </personblurb>
          <uri>http://exselt.net</uri>
        </author>
        <keywordset>
            <keyword>XML</keyword>
            <keyword>XSLT</keyword>
            <keyword>XPath</keyword>
            <keyword>streaming</keyword>
            <keyword>XSLT-30</keyword>
            <keyword>Exselt</keyword>
        </keywordset>
        <abstract>
            <para>XML and streaming, and more specifically, XSLT and streaming, is often avoided by
                programmers because they think that streaming is hard. They worry that when they
                have to rewrite their stylesheets to allow streamed processing, that the stylesheets
                become less maintainable, (much) harder to develop and that following the <emphasis role="italic">Rules on Streamability</emphasis>, in the absence of a good
                tutorial or book on the subject, is excruciatingly hard and arduous when the only
                reference they can refer to is the Latest Working Draft on XSLT, section 19.</para>
            <para>This paper goes further where a previous paper by me <xref linkend="paper-25_BRA14"/><footnote xml:id="paper-25_cfqpmanvow">
                    <para>To prevent over-self-citing and cross-referencing, I have summarized
                        relevant sections of my previous paper, so that this paper can be read on
                        its own, without the requirement to read the previous paper. However, I do
                        recommend reading it, as it serves as a good introduction to streaming in
                        XSLT.</para>
                </footnote> left off. This previous paper explains <emphasis role="italic">ten rules
                    of thumb for streaming</emphasis>, which will be briefly iterated over in this
                paper, see <xref linkend="paper-25_brief_overview"/>. This paper expands on that by showing
                streaming refactoring design patterns that turn typical non-streaming XSLT
                programming scenarios into streaming ones. They can be found in <xref linkend="paper-25_design_patterns"/>, the text being specifically geared towards
                programmers new to streaming.</para>
        </abstract>
    </info>
    <section xmlns:xl="http://www.w3.org/1999/xlink" xml:id="paper-25_disclaimer">
        <title>Disclaimer</title>
        <para>This paper discusses the new rules as they are defined in the most recent public
            Working Draft, which is, as of this writing, currently in Last Call. In some scenarios,
            it will apply fixes to this working draft that have been publicly reported on the
            BugZilla system of the W3C and that have (publicly) received a resolution by the Working
            Group. The latest version of XSLT 3.0 can be found at <xref linkend="paper-25_XSLT3"/> and the
            current version used for this paper is <xref linkend="paper-25_XSLWD"/>, which is currently in
            Last Call WD state<footnote xml:id="paper-25_jpgikvjkcu">
                <para>When a W3C Working Draft reaches <emphasis role="italic">Last Call</emphasis>
                    it means that it is the last call for people in and outside of the working group
                    to comment on the draft, before it will reach <emphasis role="italic">Proposed
                        Recommendation</emphasis> status.</para>
            </footnote>. When this paper refers to XPath, it uses the most recent version of XPath
            3.0, which is currently in Proposed Recommendation state <xref linkend="paper-25_XPPR"/>. The
            latest version of XPath 3.0 can be found at <xref linkend="paper-25_XP3"/>. The related XPath
            Functions and Operators specifications used is the Proposed Recommendation
                <xref linkend="paper-25_FOPR"/>, for which <xref linkend="paper-25_FO3"/> holds the latest
            version.</para>
        <para>Since none of these specifications is currently a W3C Recommendation, it is possible
            that details mentioned in this paper change in the future, or get removed
            altogether.</para>
        <para>Since the XSLT 3.0 specification reached Last Call status, several issues with it have
            been reported in <xref linkend="paper-25_BUGZ"/> that relate to streaming. Since some
            resolutions in these public bug reports<footnote xml:id="paper-25_dtgiglasnu">
                <para>The term "bug" is not entirely fair. Both improvement request and bug reports
                    end up in the same BugZilla repository at W3C.</para>
            </footnote> have a big influence on streamability on situations discussed in this paper,
            I often refer to these bug reports in the footnotes, so that readers can check the
            latest status on their resolution. Where possible, I only use bug reports that are
            closed, which generally means that the resolution mentioned in the bug report is
            final.</para>
    </section>
    <section xmlns:xl="http://www.w3.org/1999/xlink" xml:id="paper-25_to_stream_or_not">
        <title>To stream or not to stream?</title>
        <para>Not all data manipulation scenarios require streaming. Where and when you should
            switch to a streaming scenario may depend on many factors. This section briefly
            describes what factors may come into play.</para>
        <section xml:id="paper-25_data_size">
            <title>Size of the input data tree</title>
        
        <para>The most obvious use-case for using a streaming aproach is the size of data. As a rule
                of thumb, if the data that needs to be read and written does not fit in memory, you
                would choose a streaming approach. If your input is an XML file, and you can
                estimate the size of the output XML file or files, you should add all these
                estimates together and multiply them by three or four (depending on your processor
                and the chosen XDM), and add about 200MB to the total (again, depending on the
                processor). If this total fits into computer memory, you do not need to use
                streaming. If it does not fit, you should seriously consider using streaming
                XSLT.</para>
        </section>
        <section xml:id="paper-25_intrinsically_streamed">
            <title>Intrinsically streamed input data tree</title>
            <para>Sometimes, input is streamed by default, that is, it is not all available at once.
                In such cases, you must use streaming, because only with streamed processing does
                the processor not require to read the complete input tree at once.</para>
        </section>
        <section xml:id="paper-25_streaming_output">
            <title>Streaming output</title>
             <para>It is important to distinguish between input streaming and output streaming. The
                XSLT specification is very thorough when it comes to input streaming and all rules
                that allow streamability are written in such a way that they also allow output
                streaming, but whether or not a processor actually does output streaming is not
                directly required by the specification<footnote>
                    <para>The specification does, however, require that a processor, when operating
                        in a streaming mode, must process the input data in constant memory, which
                        implicitly requires the output stream to be flushed in time to meet that
                        requirement.</para>
                </footnote>. Similarly to input streaming, if the output data is too large to fit
                into memory, you should use a streaming approach.</para>
            <para>While processors are required to flush the output buffer in time, you should test
                the abilities of your processor in this respect, because there is no standardized
                way of testing this requirement with processors, and streaming is relatively new. If
                you run into issues with running out of memory and you suspect that the cause is
                that output flushing is not done in time, you should contact your vendor and ask for
                a fix.</para>
        </section>
        <section xml:id="paper-25_streaming_unp_text">
            <title>Streaming unparsed text</title>
            <para>This paper discusses streaming of XML, but XPath 3.0 introduces a new function,
                    <code>fn:unparsed-text-lines</code><footnote>
                    <para>See <link xl:href="http://www.w3.org/TR/xpath-functions-30/#func-unparsed-text-lines">section 14.8.6 of XPath Functions and Operators</link>.</para>
                </footnote>, which takes an external resource as input and parses it line by line.
                The original intend of that function was to allow unparsed data to be streamed,
                however the Working Group at some point decided to not formalize this requirement,
                however, the specification leaves enough room for implementors to allow streamed
                processing of data read through this function. When your intend is to do streaming
                of unparsed input, you should check the capabilities of your processor to find out
                whether it can do streaming using this function. </para>
            <para>The analysis of streaming when using unparsed text through this function, is not
                required, because the result of the function is a sequence of strings, which in
                streaming terms, is a <emphasis role="italic">grounded</emphasis> and <emphasis role="italic">motionless</emphasis> result, because it does not change the read
                pointer on an input XML tree. This may seem strange, but XPath nor XSLT have
                expressions that allow you to go from one string to another the same way you would
                go from one node to another (like accessing the parent node, the preceding sibling
                node, attribute nodes etc). Strings are not nodes, hence once you have a string you
                can do pretty much everything with it without having to worry about whether you
                stylesheet is <emphasis role="italic">guaranteed streamable</emphasis> or
                not.</para>
        </section>
    </section>
    <section xmlns:xl="http://www.w3.org/1999/xlink" xml:id="paper-25_terminology">
        <title>XSLT 3.0 streaming terminology</title>
        <para>The following paragraphs explain a few essential terms in relation to streaming. For a
            more thorough coverage of streaming terminology, and the next section, initiating
            streaming, please refer to my previous paper <xref linkend="paper-25_BRA14"/>, where these
            subjects are explained in more detail and with more examples.</para>
        <section xml:id="paper-25_guaranteed_streamability">
            <title>Guaranteed streamability</title>
            
        <para>Streaming is all about <emphasis role="italic">guaranteed streamability</emphasis><footnote>
                    <para>See  <link xl:href="http://www.w3.org/TR/xslt-30/#dt-guaranteed-streamable">section
                            19.10 in XSL Transformations 3.0</link>.</para>
                </footnote>. Knowing that your stylesheet rules, when they apply to streaming, are
                guaranteed streamable is important, because it means it will be processed in a
                streaming way on every streaming processor, that is, on any processor that supports
                the streaming feature. It is possible that individual vendors have created ways to
                allow a broader group of constructs or expressions to be streamable, but that is out
                of the scope of this paper. Guaranteed streamability is well defined in the XSLT 3.0
                specification, but the rules are complex. </para>
            <para>This paper shows the application of a simplified set of rules to existing
                scenarios and how to turn stylesheets that are not <emphasis role="italic">guaranteed streamable</emphasis><footnote>
                    <para>Technically, it is not a stylesheet that is <emphasis role="italic">guaranteed streamable</emphasis> or not, it is a construct that is. It
                        depends whether that construct needs to be applied to a streaming node,
                        which is dependent on whether the construct is used inside a template that
                        is in a streaming mode, whether it is used in streamed merging, or whether
                        it is used within, or called by the instruction
                        <code>xsl:stream</code>.</para>
                </footnote> into stylesheets that are.</para>
        </section>
        <section xml:id="paper-25_proc_streamability_support">
            <title>How to find out whether your processor supports streamability</title>
            <para>If you are uncertain whether your processor supports streaming, or whether the
                license for your processor entitles you to using it, you can use the new streaming
                system property <code>xsl:supports-streaming</code><footnote>
                    <para>See <link xl:href="http://www.w3.org/TR/xslt-30/#function-system-property">section 20.3.4 in XSL Transformations 3.0</link>.</para>
                </footnote>, which returns the value <code>yes</code> or <code>no</code> depending
                on whether the processor supports it.</para>
            <para>You can use this property with <code>xsl:use-when</code> or with XSLT branch
                instructions like <code>xsl:choose</code> to force streamed processing of your
                input. A processor that does not support streaming is still required to process your
                input the traditional way, but if you explicitly want your stylesheet to fail when
                it is used with a non-streaming processor, you can use for instance the instruction
                    <code>xsl:message</code> with <code>terminate="yes"</code> to break processing
                in such cases.</para>
        </section>
        <section xml:id="paper-25_initiate_streaming">
            <title>How to initiate streaming</title>
            <para>There are essentially three ways to initiate streaming, or five, if you count
                using <code>fn:unparsed-text-lines</code> and vendor-specific methods as well, but
                these are outside the scope of this paper. A brief overview of the three ways to
                initiate streaming:</para>
            <para>
                <orderedlist>
                    <listitem>
                        <para><emphasis>Using xsl:mode:</emphasis> with <code>xsl:mode</code><footnote>
                                <para>See <link xl:href="http://www.w3.org/TR/xslt-30/#declaring-modes">section 6.6.1 in XSL Transformations 3.0</link>, and <link xl:href="http://www.w3.org/TR/xslt-30/#streamable-templates">section 6.6.3 on Streamable Templates</link>.</para>
                            </footnote>, the attribute <code>streamable="yes"</code> means that the
                            mode, and all templates within that mode, will operate in a streaming
                            way. That means that all templates in that mode must be guaranteed
                            streamable. When you set <code>streamable="yes"</code> on the default
                            unnamed mode, all templates in the default mode must be guaranteed
                            streamable. To initiate streamed processing with a streamable mode,
                            instruct your processor, i.e. by using command line parameters, to use
                            that mode as an initial mode, in which case the processor
                                <emphasis>must</emphasis> process the initial input document by
                            using streaming.</para>
                    </listitem>
                    <listitem>
                        <para><emphasis>Using xsl:stream:</emphasis> the most obvious way to
                            initiate streaming is perhaps the new XSLT 3.0 instruction
                                <code>xsl:stream</code><footnote>
                                <para>See <link xl:href="http://www.w3.org/TR/xslt-30/#stream-instruction">section 18.1 in XSL Transformations 3.0</link>.</para>
                            </footnote>. This instructions takes a <code>href</code> attribute value
                            template and processes the document it finds using streamed processing.
                            While using the initial mode option allows a creative developer to use
                            something else then a document node as initial streamable item, the
                                <code>xsl:stream</code> instruction can only return the document
                            node in a streaming way, similar to the functions <code>fn:doc</code>
                            and <code>fn:document</code>.</para>
                        <para>Recently,  as a resolution to public <link xl:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25173">XSLT
                                3.0 Bug 25173</link>, the working group has decided to add a
                            function, <code>fn:streaming-document-available</code>, or
                                <code>fn:streaming-available</code><footnote>
                                <para>At the time of this writing, there was no consensus yet on the
                                    chosen name. Follow the linked bugreport or review the next
                                    public working draft to find out what the definitive name of
                                    this function will be.</para>
                            </footnote>. This function will take an href and try to resolve it by
                            trying to read the <code>Prolog</code> section of the XML document. How
                            the precise semantics will work out is yet unclear, but it is important
                            to realize that a streaming document is not stable, because it is not
                            kept in memory as a whole. As a result, this function will, at the very
                            most, give a <emphasis role="italic">hint</emphasis> as to whether a
                            document is available or not. On a subsequent read, it may not be there
                            any longer. This in contrast to <code>fn:doc-available</code>, which is
                            guaranteed to return true if it can read the whole document<footnote>
                                <para>This is only partially true. At user option, a processor may
                                    offer a non-stable version of <code>fn:doc</code>, which allows
                                    the processor to optimize memory usage by not having to keep the
                                    full XDM tree of the XML document in memory. As a byproduct, in
                                    such scenarios it it not guaranteed that the same document node
                                    is returned upon a subsequent invocation of that function with
                                    the same argument.</para>
                            </footnote>.</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="italic">Using xsl:merge:</emphasis> a less common way
                            to initiate streaming is by using the <code>xsl:merge</code><footnote>
                                <para>See <link xl:href="http://www.w3.org/TR/xslt-30/#element-merge">section 15.2 in XSL Transformations 3.0</link>.</para>
                            </footnote> instruction. This instruction can process multiple sorted
                            documents in order and merge them into a single output. For instance, if
                            you have a document with current users and one with new users, and you
                            want to merge them together, assuming they are sorted, you can use this
                            instruction to do so. The merge instruction takes its sources through
                                <code>xsl:merge-source</code> children, each of which can take a
                            streamable document if the attribute <code>streamable</code> is set to
                                <code>yes</code>. In-depth discussion of this instruction is out of
                            scope for this paper<footnote>
                                <para>The current Public Working Draft <xref linkend="paper-25_XSLT3"/>
                                    has some issues in regards to streamability of
                                        <code>xsl:merge</code>, making it impossible to do
                                    streaming, as I reported in <xref linkend="paper-25_BRA14"/>. The most
                                    relevant bugs are <link xl:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=24343">XSLT 3.0 Bug 24343</link> and <link xl:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25335">25335</link>. Both are meanwhile resolved.</para>
                            </footnote>, but see <xref linkend="paper-25_sec_sorting"/> for an example and
                            its applicability with sorting.</para>
                    </listitem>
                </orderedlist>
            </para>
        </section>
    </section>
    <section xmlns:xl="http://www.w3.org/1999/xlink" xml:id="paper-25_brief_overview">
        <title>Brief overview of the Ten Rules of Thumb of streaming</title>
        <para>The following ten sections serve as a quick refreshment on the basics of streaming. As
            with the previous section, these <emphasis role="italic">Ten Rules of Thumb</emphasis>
            have been more thoroughly discussed, and with ample examples, in my previous paper
                <xref linkend="paper-25_BRA14"/>. If you do not have prior experience with streaming in
            XSLT, I recommend you read the corresponding sections in that previous paper.</para>
        <section xml:id="paper-25_rule1">
            <title>Rule 1: each template rule can have a maximum of one downward expression</title>
            <para>Each template rule that is in a streamable mode can contain a maximum of one
                downward expression<footnote>
                    <para>The specification talks about at most one <emphasis role="italic">consuming</emphasis> expression. In the body of the text of this paper,
                        I typically prefer the term <emphasis role="italic">downward
                            expression</emphasis>, though sometimes it seems more applicable to use
                            <emphasis role="italic">consuming</emphasis>. Either term covers the
                        same base.</para>
                </footnote> in all of its immediate children. This is the most important rule to
                remember, but do see <xref linkend="paper-25_rule2"/>, where we are widening the concept a
                little. </para>
            <para>Example:<programlisting>&lt;!-- the whole template has
     one downward expression --&gt;
&lt;xsl:template match="amount"&gt;
  &lt;xsl:copy&gt;
    &lt;!-- the next line has
         one downward expression --&gt;
    &lt;xsl:apply-templates select="price" /&gt;
  &lt;/xsl:copy&gt;
&lt;xsl:template&gt;</programlisting></para>
            <section>
                <title>What are downward expressions?</title>
                <para>A downward expression is an expression for which the processor is required to
                    read further into the currently open stream. This is in contrast to a <emphasis role="italic">motionless</emphasis> expression, which does not require the
                    processor to move its reading head<footnote>
                        <para>When I use the term <emphasis role="italic">reading head</emphasis>,
                            it refers to a fictitious current position of the read-pointer of the
                            processor in the opened streamed document. Whether or not a processor
                            actually has such a read pointer, is an implementation detail. An
                            optimizing processor might, for instance, do some look-ahead and
                            caching, to improve up processing speed. Moving the reading head forward
                            is literally the same as reading the next bytes, and thus nodes, from
                            the input stream.</para>
                    </footnote>. Such downward expressions are, for instance, a child-select
                    expression, such as <code>child:section</code>, or a descendant-or-self
                    expression, such as <code>head//section</code>. Not all downward selections are
                    also guaranteed streamable. For instance, the expression
                        <code>following-sibling::customer</code> is not guaranteed streamable when
                    it operates on a streaming node, but is a downward expression. The term used for
                    such expressions is: <emphasis role="italic">free-ranging</emphasis>
                    expressions, which is a group of expressions that also includes non-downward
                    expressions, such as <code>ancestor::head/section</code>, which is an expression
                    that first moves up, and then down again.</para>
                <para>More on how to determine what expressions are allowed in what constructs, is
                    explained in the following sections.</para>
            </section>
        </section>
        <section xml:id="paper-25_rule2">
            <title>Rule 2: each individual construct can have a maximum of one downward
                expression</title>
            <para>Let us extend the previous rule a little bit by saying that each construct has a
                maximum of one downward expression. In streaming, a <emphasis role="italic">construct</emphasis> is an instruction, an expression, a sub-expression (in
                    <code>a | b</code> there are two subexpressions <code>a</code> and
                    <code>b</code>) and declarations, if they are of influence to streamability.
                Typically, many constructs have a sequence constructor (such as
                    <code>xsl:for-each</code>, <code>xsl:sequence</code>,
                    <code>xsl:with-param</code>). This sequence constructor is at the heart of XSLT
                which allows us to nest instructions inside other instructions. A sequence
                constructor is itself a <emphasis role="italic">construct</emphasis> as seen in
                streaming analysis.</para>
            <para>It is important to distinguish between focus-changing constructs, such as
                    <code>xsl:for-each</code> and non-focus-changing constructs. When a construct
                changes focus, the expression changing the focus (usually the <code>select</code>
                attribute) can be a downward expression <emphasis role="italic">and</emphasis> the
                sequence constructor inside the container can have a downward expression.</para>
            <para>Another focus-changing construct is the path operator. In an expression such as
                    <code>a/b/c</code>, each of <code>a</code>, <code>b</code> and <code>c</code> is
                considered a construct<footnote>
                    <para>The specification differentiates between constructs and operands. In fact,
                        both the <code>xsl:for-each</code> and the path expression has several
                        operands, each of which follows certain rules. The instruction and path
                        expression as a whole are considered a construct in the specification. This
                        paper does not make that distinction, which in many cases makes analysis
                        easier. In those cases where it is not applicable, I will explicitly mention
                        it.</para>
                </footnote>, because each <code>/</code>-operator changes the focus. That is why it
                is allowed to write essentially <emphasis role="italic">three</emphasis> downward
                expressions in <code>a/b/c/</code>.</para>
            <para>Conversely, the container of <code>xsl:if</code> does not change focus. As a
                result, the whole <code>xsl:if</code>-instruction is considered on construct, and
                either the <code>test</code>-attribute or the sequence constructor can contain a
                downward expression, but not both.</para>
            <para>Filter expressions, as in <code>head/section[para]</code> do not change focus
                either, and since you already have a downward select in the other part of the
                expression, the <code>para</code> child-select expression is considered the second
                downward expression. The whole expression <code>head/section[para]</code> is
                therefor not streamable. See <xref linkend="paper-25_rule9"/> for more on filters.</para>
        </section>
        <section xml:id="paper-25_rule3">
            <title>Rule 3: Use motionless expressions where possible</title>
            <para>A motionless expression, or construct, is one that doesn't require the processor
                to move from the current point in the input XML stream at all. Such expressions are
                expressions that do not operate on nodes, or expressions that request information
                from a node, such as its name, and can give that information without moving the
                reading head. Some examples of motionless expressions are:<itemizedlist>
                    <listitem>
                        <para><code>fn:name()</code>, <code>fn:local-name</code> and
                                <code>self::foo</code>. Also functions such as
                                <code>fn:has-children</code><footnote>
                                <para>Intu√Øtively, the function <code>fn:has-children</code>
                                    requires look-ahead. But since it only requires a very small
                                    look-ahead, it is considered streamable. Implementations just
                                    need to make sure they don't actually move the reading
                                    head.</para>
                            </footnote>, <code>fn:exists</code> and
                                <code>fn:in-scope-prefixes</code>.</para>
                    </listitem>
                    <listitem>
                        <para>Climbing the parent, ancestor or ancestor-or-self axes (but not
                            downward again after you climb). The reason this is allowed is that
                            during streaming, the processor keeps a cache of all the ancestors of
                            the current node.</para>
                    </listitem>
                    <listitem>
                        <para>The attribute axis. Similar to the previous rule, attributes are
                            considered part of the information of the current node. Combining the
                            previous rule and this rule is possible, for instance,
                                <code>author/ancestor::*/@company-name</code> is a guaranteed
                            streamable expression.</para>
                    </listitem>
                    <listitem>
                        <para>Atomic functions or functions that operate on atomics, as long as the
                            current node is not an argument. The expression
                                <code>fn:string(math:pow(3.14))</code> is motionless, but the
                            expression fn:string(math:pow(input)) is not, the second has a child
                            expression as argument and is, on itself, a downward expression and
                                <emphasis role="italic">not</emphasis> motionless.</para>
                    </listitem>
                    <listitem>
                        <para>Literal result elements or node creation instructions (unless of
                            course, they contain an AVT<footnote>
                                <para>The term AVT means attribute value template, a way of writing
                                    an expression as a value of an attribute using
                                        <code>{expr}</code> syntax.</para>
                            </footnote> a TVT<footnote>
                                <para>A TVT, or text value template, is a new feature of XSLT 3.0
                                    which allows you to intermix expressions with text nodes, see
                                    also <link xl:href="http://www.w3.org/TR/xslt-30/#dt-text-value-template">section 5.7.2 in XSL Transformations 3.0</link>.</para>
                            </footnote> or a sequence constructor that has a downward
                            expression).</para>
                    </listitem>
                    <listitem>
                        <para>Variable references are motionless<footnote>
                                <para>It is not allowed in streaming to bind a variable to a
                                    streaming node.</para>
                            </footnote> unless they occur inside <code>xsl:function</code> and are
                            bound to a <emphasis role="italic">streaming argument</emphasis><footnote>
                                <para>This is a notable difference between my previous paper
                                        <xref linkend="paper-25_BRA14"/> and this one. It is not possible
                                    anymore to bind grouping or merging variable using
                                        <code>bind-group</code>, instead, using
                                        <code>fn:current-group</code> and friends is legal, with
                                    certain restrictions, in streaming, see <link xl:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=24510">XSLT 3.0 Bug 24510</link>. Conversely, it is now possible
                                    to write stylesheet functions that take at most one streaming
                                    argument (and argument that can be a reference to a node), see
                                        <link xl:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25679">XSLT 3.0 Bug 25679</link>.</para>
                            </footnote>. Note that it <emphasis role="italic">is</emphasis> possible
                            to create <emphasis role="italic">copies</emphasis> of nodes and bind
                            those to variables, see <xref linkend="paper-25_rule6"/>.</para>
                    </listitem>
                </itemizedlist></para>
        </section>
        <section xml:id="paper-25_rule4">
            <title>Rule 4: You can move up the tree, but never down again</title>
            <para>The ancestor axis, together with the attributes and properties of the nodes, is
                the only axis that is kept in memory while performing streaming. As a result, you
                can consider the ancestor axis as a stack that is always available. However, while
                you can create a motionless expression like <code>parent::x/@name</code>, you are
                not allowed to move away again, because moving down would mean that you move the
                input read pointer in an arbitrary direction<footnote>
                    <para>This is called <emphasis role="italic">free ranging</emphasis> in the
                        specification.</para>
                </footnote>. An example of such a <emphasis role="italic">free-ranging</emphasis>
                expression is <code>parent::x/address</code>, because that expression moves up, and
                then selects the child (moving down).</para>
        </section>
        <section xml:id="paper-25_rule5">
            <title>Rule 5: You cannot store a reference to a node</title>
            <para>This rule was already touched upon in <xref linkend="paper-25_rule3"/>. It is very easy to
                master: you cannot store a reference to a streaming node, <emphasis role="italic">ever</emphasis><footnote>
                    <para>A processors is allowed to extend the streamability rules. However, the
                        term <emphasis role="italic">guaranteed streamability</emphasis>, which this
                        paper discusses, is guaranteed across different streaming processors. Vendor
                        extensions are out of scope for this paper.</para>
                </footnote> . A reference to a node can be created within a <code>let</code>
                expression, an <code>xsl:variable</code> or an <code>xsl:param</code> instruction,
                or implicitly, as an argument to a stylesheet function<footnote>
                    <para>Since the resolution of <link xl:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25679">XSLT 3.0
                            Bug 25679</link> on Streamable stylesheet functions, it is now possible
                        for a stylesheet function parameter to be bound to a node. As a consequence,
                        it is possible for a variable reference, if bound to such a parameter, to be
                        bound to a node. The resolution of this bug is not public, but the essence
                        is important for writing library packages catered for streaming, which would
                        otherwise not be possible.</para>
                </footnote> .</para>
            <para>Example that is not guaranteed
                streamable:<programlisting>&lt;xsl:template match="log" mode="streaming"&gt;
  &lt;!-- not allowed:
         binding a node to a variable --&gt;
  &lt;xsl:variable select="detail" name="dtl"/&gt;
  &lt;xsl:value-of select="$dtl" /&gt;
&lt;/xsl:template&gt;</programlisting>
                Example that is guaranteed streamable<footnote>
                    <para>The example here uses the fact that the sequence constructor, by default,
                        creates a new document node. In addition, the <code>xsl:copy-of</code>
                        instruction creates a copy of the node too, disconnecting it from the
                        streaming node and consuming the whole node at once.</para>
                </footnote>:<programlisting>&lt;xsl:template match="log" mode="streaming"&gt;
  &lt;!-- allowed: creating a document
                node with a copy of a node --&gt;
  &lt;xsl:variable name="dtl"&gt;
    &lt;xsl:copy-of select="detail" /&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:value-of select="$dtl" /&gt;
&lt;/xsl:template&gt;</programlisting></para>
        </section>
        <section xml:id="paper-25_rule6">
            <title>Rule 6: Break out of streaming abundantly</title>
            <para>In <xref linkend="paper-25_rule5"/> you have seen an example that created a copy of a node
                and stored that inside a variable. This comes in handy, but such a copy does no
                maintain information from its ancestors, and creating a copy that does maintain that
                information is not obvious<footnote>
                    <para>For an example of how complex this is to do by hand, see the 75 lines long
                        formal function that defines <code>fn:snapshot</code> in <link xl:href="http://www.w3.org/TR/xslt-30/#func-snapshot">section 18.4 of
                            XSL Transformation 3.0</link></para>
                </footnote>. For cases where an inline expression should break out of streaming and
                create a copy of a node, maintaining all the information from its ancestors, XSLT
                3.0 introduced the new function <code>fn:snapshot</code>. If the ancestors are not a
                requirement, you can use the lighter-weight funtion <code>fn:copy-of</code>.</para>
            <para>Use these functions abundantly, possibly in conjunction with
                    <code>xsl:copy-of</code>. They create an in-memory copy of whatever node you
                feed them, and on that copy, you can use any free-ranging expression that you
                like.</para>
            <para>One caveat: usually, you will choose a streaming scenario for a reason, for
                instance because the input is too large to fit in memory. Do not use these functions
                on nodes that are potentially too large to fit in memory. Use them on nodes that you
                know are small enough to be processed one at a time in memory<footnote>
                    <para>A processor is not required to dismiss memory after one of these functions
                        are used, but it is likely that implementations will dismiss off memory of
                        copies that go out of scope, otherwise, these functions would have little
                        merit in long-running streaming scenarios.</para>
                </footnote>.</para>
        </section>
        <section xml:id="paper-25_rule7">
            <title>Rule 7: Understand streamable patterns</title>
            <para>In essence: patterns must be motionless. Imagine any current node and its
                available information, like its ancestors, its attributes and its properties. If you
                consider a pattern as a function that returns <emphasis role="italic">true</emphasis> or <emphasis role="italic">false</emphasis>, and if that
                function can be applied without moving away from that current node, then it is a
                motionless pattern.</para>
            <para>A pattern behaves different from expressions. Take an select expression such as
                    <code>book/chapter</code>. As an expression, this is considered a downward
                expression, because it <emphasis role="italic">selects</emphasis> the nodes below
                the current node, so it must move the reading head. However, patterns are evaluated
                on every node when they are encountered. When the processor encounters a node with
                the name <code>section</code>, it knows instantly, without looking ahead or
                backwards that the pattern does not match the right-hand part <code>chapter</code>
                of the expression: the name does not match. If it finds a node with the name
                    <code>chapter</code>, it can check the parent without moving the reading head
                whether it matches <code>book</code>. Conclusion: <code>book/chapter</code> is a
                    <emphasis role="italic">motionless pattern</emphasis><footnote>
                    <para>See <link xl:href="http://www.w3.org/TR/xslt-30/#classifying-patterns">section on Classifying Constructs in XSL Transformation
                        3.0</link>.</para>
                </footnote> and therefore streamable.</para>
            <para>All patterns that do not start with a variable reference or a function call, and
                that do not have a predicate, are streamable. Examples are <code>html//div</code>,
                    <code>a//b//c//d</code>, <code>child:num</code>, <code>author/@name</code> and
                    <code>author/@name</code><footnote>
                    <para>Recall that a pattern is not the same as an expression. For instance, you
                        cannot write path expression using the following-sibling or parent axis.
                        This was true in XSLT 1.0 and 2.0 and remains true in XSLT 3.0.</para>
                </footnote>.</para>
            <para>If your pattern has a predicate, that predicate must be motionless, similar to
                    <xref linkend="paper-25_rule9"/>, but must not be a numeric predicate. In nested
                predicates, however, you can use a numeric value or <code>fn:position</code>, but
                they still must be motionless. Valid examples are <code>author[@name]</code>,
                    <code>author[ancestor::guild]</code> and
                    <code>author[ancestor::*[3][self::publisher]]</code>, the latter having a
                numeric predicate, which is allowed because the predicate is nested.</para>
        </section>
        <section xml:id="paper-25_rule8">
            <title>Rule 8: Use atomic types to ground the result of templates</title>
            <para>Any template rule or named template must be <emphasis role="italic">grounded</emphasis><footnote>
                    <para><emphasis role="italic">Grounded</emphasis> means that it cannot return
                        streaming nodes.</para>
                </footnote>, which means, it is not allowed to return streaming nodes. This rule is
                very similar <xref linkend="paper-25_rule5"/>. Since using <code>xsl:sequence</code> inside
                bodies of <code>xsl:template</code> is very common, and since
                    <code>xsl:sequence</code> return a reference of a node, you should be careful
                about using them.</para>
            <para>But there is an easier way out. Instead of trying to keep track on whether or not
                your template returns nodes, it is much simpler to correctly set an atomizing type<footnote>
                    <para>An atomizing type is any type that is not a node type, or cannot be a node
                        type. Examples are <code>xs:string</code>, <code>xs:integer</code>,
                            <code>xs:double*</code>, but not <code>element()</code>,
                            <code>attribute()</code> or <code>item()</code>.</para>
                </footnote> for your template. When a type is set for your template, the processor
                must atomize the result anyway, so it <emphasis role="italic">knows</emphasis>
                statically that the template will never return any nodes. This prevents you from
                worrying about whether or not you are returning nodes or not. The principle of
                    <emphasis role="italic">taking the result type into account</emphasis> also
                applies to other constructs, such as the parameter and return types of stylesheet
                functions and templates, or the declarations of variables.</para>
            <para>If you want to return more complex content than an atomic type, use
                    <code>xsl:copy</code> and similar constructs that create copies of nodes, as
                opposed to <code>xsl:sequence</code>, which returns references to nodes.</para>
        </section>
        <section xml:id="paper-25_rule9">
            <title>Rule 9: Use motionless filters</title>
            <para>In earlier chapters we have already seen what a motionless expression is. In
                filter expressions, that is, in a predicate, you should always only use motionless
                expressions, or the result will not be streamable. Some
                examples:<programlisting>price/text()[contains(., 'father'')]
child::node()/copy-of(.)[contains(., 'father')]
helptext[@version = '3.14']
.//comment()[contains(., 'father')]
p[parent::div][ancestor::p][@xml:lang]</programlisting></para>
            <para>All the above expressions use motionless filters, but they are motionless for
                different reasons. </para>
            <para>The first is motionless because <code>text()</code>-nodes considered leave-nodes
                (they cannot possibly have children). A filter expression on a guaranteed childless
                node may consume that whole node, here done by the context-item expression
                    <code>.</code>. </para>
            <para>The second is motionless because we first created a copy of the whole node using
                    <code>copy-of</code>, after that, anything we do on that node, can be any
                regular XPath expression, see also <xref linkend="paper-25_rule6"/>.</para>
            <para>The third tests the value of an attribute, attributes are always available as part
                of the stack the processor keeps of each node: an attribute is a property of a node
                and henceforth it is motionless.</para>
            <para>The fourth is a filter on a comment. Similarly to text-nodes, comments can never
                have children, so the expression is allowed to consume the whole node and still be
                considered motionless<footnote>
                    <para>In fact, this is precisely how the specification defines it: consuming a
                        childless node is considered a motionless operation. This may seem like a
                        constradiction in terms, but helps a lot with keeping the analyzing terms to
                        a minimum. The official rule is, however, not very easy to read and
                        understand: <emphasis role="italic">If U is absorption and T is a childless
                            node kind (text(), attribute(), comment(), processing-instruction, or
                            namespace-node()), then U' is inspection</emphasis>, see <link xl:href="http://www.w3.org/TR/xslt-30/#dt-general-streamability-rules">Section 19.8, General Streamability Rules in XSL Transformation
                            3.0</link>.</para>
                </footnote>.</para>
            <para>The last example combines three motionless filters and searches for illegally
                nested <code>p</code> elements in an HTML document, that also have the
                    <code>xml:lang</code>-attribute set. The parent axis, the ancestor axis and the
                attribute axis are all part of the available properties that are maintained by the
                processor as a stack during processing, therefore this expression is motionless
                too.</para>
        </section>
        <section xml:id="paper-25_rule10">
            <title>Rule 10: Master xsl:fork</title>
            <para>There is an alternative for scenarios where you would otherwise require multiple
                downward selects in one construct. Use <code>xsl:fork</code><footnote>
                    <para>See also <link xl:href="http://www.w3.org/TR/xslt-30/#fork-instruction">section 16.1 in  XSL Transformations 3.0</link></para>
                </footnote>, which explicitly tells the processor that from this point on, it should
                start multiple threads for processing the input stream in parallel. In other words,
                the stream reader will get multiple read pointers that all have their own starting
                point, the current node. This process, called <emphasis role="italic">forking</emphasis> allows multiple downward selections in a single instruction,
                but is very strictly defined.</para>
            <para>The rules for using <code>xsl:fork</code> are briefly as follows:<itemizedlist>
                    <listitem>
                        <para>It can only contain <code>xsl:sequence</code> children</para>
                    </listitem>
                    <listitem>
                        <para>Each <code>xsl:sequence</code> can have at most one downward select
                            expression, as explained in <xref linkend="paper-25_rule2"/>.</para>
                    </listitem>
                    <listitem>
                        <para>Each <code>xsl:sequence</code> must be grounded, as in <xref linkend="paper-25_rule8"/>, it cannot return nodes, but this time you cannot
                            use the <code>as</code>-attribute to the rescue, so type-determined
                            usage, as also discussed in the same <emphasis role="italic">Rule
                                Eight</emphasis>, cannot be applied<footnote>
                                <para>In practice this means that you must wrap the sequence
                                    constructor of each <code>xsl:sequence</code> in
                                        <code>xsl:copy</code> of <code>xsl:value-of</code>or
                                    likewise constructs that return copies, not references to
                                    nodes.</para>
                            </footnote>.</para>
                    </listitem>
                </itemizedlist></para>
            <para>Once you have these rules in place, you are allowed multiple selections in a
                single construct, you can <emphasis role="italic">fork</emphasis> the processing. In
                fact, that is exactly what you tell the processor: from hear on in, I want multiple
                reading heads on the same stream.</para>
            <para>Example of splitting logfile entries between warnings and errors<footnote>
                    <para>Example was directly taken from <xref linkend="paper-25_BRA14"/>, page 21, where
                        you can find more information on using <code>xsl:fork</code>.</para>
                </footnote>:<programlisting>&lt;xsl:fork&gt;
 &lt;xsl:sequence&gt;
   &lt;errors&gt;
     &lt;!-- one downward select --&gt;
     &lt;xsl:copy-of select="entry[@type eq 'err']"/&gt;
   &lt;/errors&gt;
 &lt;/xsl:sequence&gt;
 &lt;xsl:sequence&gt;
   &lt;warnings&gt;
     &lt;!-- and another one, but still legal! --&gt;
     &lt;xsl:copy-of select="entry[@type eq 'warn']"/&gt;
   &lt;/warnings&gt;
 &lt;/xsl:sequence&gt;
&lt;/xsl:fork&gt;
</programlisting></para>
        </section>
        
    </section>
    <section xmlns:xl="http://www.w3.org/1999/xlink" xml:id="paper-25_design_patterns">
        <title>Streaming Design Patterns</title>
        <para>In the following sections, I will show programming design patterns that are common in
            traditional, non-streaming scenarios, but that are themselves roaming and free-ranging
            expressions or constructs. As a result, they cannot be used in a streaming scenario by
            copying them one-on-one.</para>
        <para>The streaming design patterns apply both to converting existing stylesheets, and
            making them streamable, as to new stylesheets that have to be streamable from the
            beginning. </para>
        <para>Each pattern follows the same format:<itemizedlist>
                <listitem>
                    <para><emphasis role="italic">Intent:</emphasis> a brief summary of the patterns
                        intent.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="italic">Level:</emphasis> an indication for the level of
                        experience required to understand an implement the pattern<footnote>
                            <para>The level indicated is solely based on my experience within the
                                XSLT 3.0 Working Group, where certain subjects appeared to be much
                                harder to be understood by the group members, while others were
                                relatively easy to grasp.</para>
                        </footnote>. Under the <emphasis role="italic">Level</emphasis> section, I
                        will also mention the level of streamability the solution has after applying
                        the streaming pattern, in order, from <emphasis role="italic">full</emphasis> to <emphasis role="italic">none</emphasis>:<itemizedlist>
                            <listitem>
                                <para><emphasis role="italic">Full:</emphasis> means the streaming
                                    pattern is fully streamable, without buffering or copying
                                    nodes.</para>
                            </listitem>
                            <listitem>
                                <para><emphasis role="italic">Implicitly windowed:</emphasis>
                                    technically the same a <emphasis role="italic">full</emphasis>,
                                    but applies to constructs such as <code>xsl:try</code><footnote>
                                        <para>The instruction <code>xsl:try</code> deserves special
                                            attention. It does not create copies of streamed input,
                                            but it buffers (creates a copy) of streamed output,
                                            because in the event of a failure, the processor is
                                            required to rollback to the point before the
                                                <code>xsl:try</code> instruction.</para>
                                    </footnote> and <code>xsl:merge</code> where the current merge
                                    group is implicitly copied, and thus grounded<footnote>
                                        <para>I would like to liberally quote Michael Kay here as I
                                            heard him explaining this concept: <quote>in the vast
                                                majority of cases, the implicit copy will be small,
                                                only a few pathological cases may require a large
                                                copy, in which case it is up to the stylesheet
                                                author to come up with a better solution</quote>.
                                            This change is not currently in the public spec, however
                                            see <link xl:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25335">XSLT 3.0 Bug 25335</link>.</para>
                                    </footnote>.</para>
                            </listitem>
                            <listitem>
                                <para><emphasis role="italic">Modified windowed:</emphasis> same as
                                        <emphasis role="italic">windowed</emphasis> below, but first
                                    a limited, modified copy of the nodes is created to prevent
                                    taking up too much memory.</para>
                            </listitem>
                            <listitem>
                                <para><emphasis role="italic">Windowed:</emphasis> the streaming
                                    pattern uses windowed streaming, meaning that a copy of a node
                                    or nodes is created in memory to do further processing on
                                    without the restrictions of streaming.</para>
                            </listitem>
                            <listitem>
                                <para><emphasis role="italic">Multiple pass:</emphasis> the
                                    streaming pattern uses multiple passes on the input document;
                                    this ensures limited use of memory, but may (dramatically)
                                    increase processing time.</para>
                            </listitem>
                            <listitem>
                                <para><emphasis role="italic">None:</emphasis> no streaming solution
                                    exists.</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
                <listitem>
                    <para><emphasis role="italic">Motivation:</emphasis> explains why this pattern
                        does not work using the traditional, non-streamable approach.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="italic">Applicabilty:</emphasis> a summary of typical
                        scenarios this pattern applies to.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="italic">Consequences:</emphasis> an enumeration of
                        possible drawbacks of the pattern.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="italic">Implementation:</emphasis> step-by-step guide to
                        implement this pattern on existing code.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="italic">Example:</emphasis> applies the design pattern and
                        applies it to the example from the <emphasis role="italic">Motivation</emphasis> section.</para>
                </listitem>
            </itemizedlist></para>
        <section xml:id="paper-25_filter_dependon_children">
            <title>Filter expression depends on children</title>
            <section>
                <title>Intent</title>
                <para>You have a select expression with a predicate that depends on data in the
                    children and want to make it streamable.</para>
            </section>
            <section>
                <title>Level</title>
                <para>Intermediate: uses techniques available in XSLT 2.0. Streamability level:
                    modified windowed.</para>
            </section>
            <section>
                <title>Motivation</title>
                <para>Suppose your data structure looks something like the following, where the
                    elements <code>largedata</code> contain potentially large sections of data that
                    you do not want copied, for instance base64 formatted images or other data
                    related to the
                    person:<programlisting language="xml">&lt;people&gt;
    &lt;person&gt;
       &lt;largedata&gt;
       &lt;name&gt;...
       &lt;largedata&gt;
       &lt;address&gt;
          &lt;largedata&gt;
          &lt;street&gt; ...
          &lt;number&gt; ...
          &lt;city&gt; ...
          &lt;state&gt;MA&lt;/state&gt;
          &lt;largedata&gt;
       &lt;/address&gt;
       &lt;largedata&gt;
    &lt;/person&gt;
    &lt;person&gt;
       ....
&lt;/people&gt;</programlisting></para>
                <para>If your requirement is to copy certain fields from <code>person</code>, based
                    on whether they live in a certain state, you may have originally used a coding
                    pattern like the
                    following:<programlisting>&lt;xsl:template match="people"&gt;
  &lt;xsl:apply-templates
    select="person[address[state = 'MA']]" /&gt;
&lt;/xsl:template&gt;</programlisting></para>
                <para>In a streaming scenario, this will not be guaranteed streamable, because
                    inside the <code>select</code> attribute, the expression uses two downward
                    selects in two filter expressions, and we know from <xref linkend="paper-25_rule9"/> that
                    that is not allowed. The select expression would not even have worked if you had
                    only one downward expression inside the predicate.</para>
                <para>A quick and easy way to fix this example is the following, applying <xref linkend="paper-25_rule6"/>:<programlisting>&lt;xsl:template match="people" mode="streaming"&gt;
  &lt;xsl:apply-templates
    select="copy-of(person)[
              address[state = 'MA']]"/&gt;
&lt;/xsl:template&gt;</programlisting></para>
                <para>This works, but what if the data of one <code>person</code> is too large (for
                    instance, the record contains binhex image or video data that you would like to
                    strip), or the memory constraints too streneous (as on mobile or embedded
                    devices), such that in your case <code>fn:copy-of</code> selects too much data
                    and blows up the processing? </para>
                <para>In such cases, use this pattern to use a guaranteed streamable approach to
                    create a partial copy of the offending element instead.</para>
            </section>
            <section>
                <title>Applicability</title>
                <section>
                    <title>Applies to</title>
                    <para>This pattern applies to almost any place where you can use an
                        expression:</para>
                    <orderedlist>
                        <listitem>
                            <para>Select expressions as used in the likes of
                                    <code>xsl:copy-of</code>, <code>xsl:copy</code><footnote>
                                    <para>Since XSLT 3.0, it is possible to have a
                                            <code>select</code> attribute on <code>xsl:copy</code>,
                                        see <link xl:href="http://www.w3.org/TR/xslt-30/#shallow-copy">section 11.9.1 on shallow copying in XSL Transformation
                                            3.0</link>.</para>
                                </footnote>, <code>xsl:apply-templates</code>,
                                    <code>xsl:for-each</code>, <code>xsl:for-each-group</code> and
                                    <code>xsl:message</code>;</para>
                        </listitem>
                        <listitem>
                            <para>Select expressions in <code>xsl:with-param</code> and
                                    <code>xsl:variable</code>, which works, because the result of
                                the pattern below is guaranteed grounded.;</para>
                        </listitem>
                        <listitem>
                            <para>Select expressions that are atomized or require a boolean, like in
                                    <code>xsl:analyze-string</code>, <code>xsl:if</code>,
                                    <code>xsl:when</code>, <code>xsl:comment</code> and
                                    <code>xsl:processing-instruction</code>;</para>
                        </listitem>
                        <listitem>
                            <para>Expressions used with atomizing arguments of any internal or user
                                function, such as where the argument is <code>xs:string</code> or
                                    <code>xs:integer*</code>.</para>
                        </listitem>
                    </orderedlist>
                </section>
                <section>
                    <title>Does not apply to</title>
                    <para>This pattern does not apply to:</para>
                    <orderedlist>
                        <listitem>
                            <para>Matching patterns, see <xref linkend="paper-25_patterns_nonmotionless"/>.</para>
                        </listitem>
                    </orderedlist>
                </section>
            </section>
            <section>
                <title>Consequences</title>
                <para>Applying this pattern has the following consequences:<orderedlist>
                        <listitem>
                            <para>Extra code for creating a partial copy of the node may impede
                                maintainability.</para>
                        </listitem>
                        <listitem>
                            <para>With more complex expressions, it can get cumbersome to split it
                                up, in which case you should look whether you can use windowed
                                streaming, using <code>fn:copy-of</code> or
                                <code>fn:snapshot</code>. But that may not be possible if the
                                selected nodes are too large to begin with.</para>
                        </listitem>
                    </orderedlist></para>
            </section>
            <section>
                <title>Implementation</title>
                <para>The essence of this pattern is to create a limited copy of the node before you
                    apply the predicate, and then apply the predicate on this copy, which is allowed
                    in streaming. The copy will only contain the leaf elements we are interested in,
                    not the large data sections such as <code>largedata</code> from our
                    example.</para>
                <para>Refactor your original code by applying the following steps in order:<orderedlist>
                        <listitem>
                            <para>Introduce a streamable mode and set the attribute
                                    <code>on-no-match="shallow-copy</code><footnote>
                                    <para>The on-no-match mode <code>shallow-copy</code> will copy
                                        any non-matching nodes, which allows us to remove only the
                                        nodes we are not interested in, without changing the whole
                                        stylesheet, this attribute, as well as the
                                            <code>xsl:mode</code> declaration, are new features of
                                        XSLT 3.0.</para>
                                </footnote>.</para>
                        </listitem>
                        <listitem>
                            <para>Remove the offending filter expression.</para>
                        </listitem>
                        <listitem>
                            <para>Create a new matching delete-template that matches the large nodes
                                we want to skip.</para>
                        </listitem>
                        <listitem>
                            <para>Add a template that matches the offending element.</para>
                        </listitem>
                        <listitem>
                            <para>In it, add a variable to create a partial copy of the offending
                                element.</para>
                        </listitem>
                        <listitem>
                            <para>Process this variable with your original predicate and templates.
                                This works, because variable references are grounded by default and
                                you can use free-ranging expressions on them<footnote>
                                    <para>Swtiching modes from a streaming mode to a non-streaming
                                        mode is allowed, as long as the select-expression does not
                                        return nodes from the streamed document, which is why this
                                        pattern creates a copy of a subset of the nodes.
                                        Alternatively, you can stay inside the new streaming mode,
                                        but this restricts the bodies of the templates.</para>
                                </footnote>.</para>
                        </listitem>
                    </orderedlist></para>
                <section>
                    <title>Example</title>
                    <para>If we apply these six steps to our original example, we end up with the
                        following code:
                        <programlisting>&lt;!-- (1) add a streamable mode --&gt;
&lt;xsl:mode name="streaming" streamable="yes"
          on-no-match="shallow-copy" /&gt;

&lt;!-- (1) use the streamable mode --&gt;
&lt;xsl:template match="people" mode="streaming"&gt;
  &lt;!-- (2) remove the filter-expression --&gt;

  &lt;xsl:apply-templates select="person"
                       mode="#current" /&gt;
&lt;/xsl:template&gt;

&lt;!-- (4) add a template matching "person" --&gt;
&lt;xsl:template match="person" mode="streaming"&gt;

  &lt;!-- (5) introduce a variable
           to copy partially --&gt;
  &lt;xsl:variable name="person-partial"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="@*"
                           mode="#current" /&gt;
      &lt;xsl:apply-templates select="node()"
                           mode="#current" /&gt;
    &lt;xsl:copy&gt;
  &lt;/xsl:variable&gt;
  &lt;!-- (6) continue in the non-streaming
           mode on the elementcopy --&gt;

  &lt;xsl:apply-templates select="$person-partial/
    person[address[state = 'MA']]" /&gt;
&lt;/xsl:template&gt;

&lt;!-- (3) create a delete-template
         for the large nodes --&gt;
&lt;xsl:template
  match="node()[ancestor-or-self::largedata]"
  mode="streaming"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates mode="#current"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;

&lt;!-- (3) create a matching pattern
         for the inclusive elements --&gt;
&lt;xsl:template
  match="address/*[not(self::largedata)]"
  mode="streaming"&gt;
  &lt;xsl:copy-of select="." /&gt;
&lt;/xsl:template&gt;</programlisting></para>
                    <para>In the above code, you can see that we specify what parts of the streaming
                        input data we want to delete<footnote>
                            <para>There are many ways of writing an appropriate delete-template. I
                                chose for <code>ancestor-or-self</code>, but you may require a more
                                fine-grained approach in your situation. Remember that any nodes not
                                specifically speficied in a matching pattern are copied as a result
                                of <code>on-no-match="shallow-copy</code>.</para>
                        </footnote>, so that the copy of the nodes is as small as possible, i.e.
                        without any of the large nodes. The result, a handful of nodes with string
                        data as content, is copied into a variable. In turn, the contents of this
                        variable, which is now <emphasis role="italic">grounded</emphasis>, is
                        copied to the final result tree, using the same predicate we used
                        previously.</para>
                    <para>Note the special variant of the identity template. Instead of placing
                            <code>node | @*</code> in one select-statement, it is split into two.
                        The reason behind this is that a <emphasis role="italic">climbing</emphasis><footnote>
                            <para>A climbing expression is an expression that <emphasis role="italic">climbs up</emphasis> the tree, as we have seen in
                                    <xref linkend="paper-25_rule4"/>. Attributes are considered <emphasis role="italic">climbing</emphasis>.</para>
                        </footnote> expression and a <emphasis role="italic">striding</emphasis><footnote>
                            <para>A striding expression is an expression on the child axis or a
                                combination of child axes, where overlapping nodes will not
                                occur.</para>
                        </footnote> expression cannot be combined in a single <code>union</code>
                        expression. However, a climbing expression that only selects leaf nodes<footnote>
                            <para>As seen before, a leaf node is a node without children. Attributes
                                and text-nodes are leaf nodes, but a climbing expression like
                                    <code>ancestor::title</code> is not, because <code>title</code>
                                can have children.</para>
                        </footnote> is allowed on its own in a select-satement, as is a striding
                        expression.</para>
                    <para>The benefits of using this pattern is that you can leave much of your
                        original code intact. We merely removed the nodes that made streaming
                        impossible, and then continued processing on a small copy of the
                        nodes.</para>
                    <para>After we have applied our changes, the total amount of memory required for
                        this whole operation is much less than in the first solution, where we
                        copied the entire <code>&lt;person&gt;</code> element as a convenient quick
                        solution. While there are methods you can use that may use even less memory,
                        for instance with accumulators and maps, but these approaches are far harder
                        to implement and in this particular scenario may only gain a couple of bytes
                        for you during processing.</para>
                </section>
            </section>
        </section>
        <section xml:id="paper-25_patterns_nonmotionless">
            <title>Patterns with non-motionless predicates</title>
            <section>
                <title>Intent</title>
                <para>You have a matching pattern that depends on its children and want to make it
                    streamable.</para>
            </section>
            <section>
                <title>Level</title>
                <para>Easy: uses common, well-known XSLT 2.0 techniques. Streamability level:
                    windowed.</para>
            </section>
            <section>
                <title>Motivation</title>
                <para>Suppose you want to select all <code>para</code> elements that contain an
                        <code>emphasis</code> element and you want to remove all other
                        <code>para</code> elements. In a non-streaming scenario, your stylesheet
                    could look something like
                    this:<programlisting>&lt;xsl:template match="para[descendant::emphasis]"&gt;
  &lt;xsl:copy-of select="." /&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="para" /&gt;
</programlisting></para>
                <para>This pattern is not streamable, because it requires the processor to look down
                    inside all possible children of the <code>para</code> element and after that, it
                    should go back and copy everything from beginning to end.</para>
                <para>In fact, as explained in <xref linkend="paper-25_rule7"/>, a predicate in a pattern
                    must be motionless. Because you are not allowed to use <emphasis role="italic">windowed template matching</emphasis> using <code>fn:snapshot</code> or
                        <code>fn:copy</code><footnote>
                        <para>Windowed template matching does not exist (yet), but it borrows the
                            term from <emphasis role="italic">windowed streaming</emphasis>, which
                            creates a copy of a small subset of nodes. Windowed template matching
                            could look like <code>para[copy-of(.)/descendant::emphasis]</code>, but
                            this is not legal in streaming, and outside of streaming the
                                <code>fn:copy-of</code> has no effect.</para>
                    </footnote>, this pattern's solution takes an old-school imperative approach to
                    solve the non-motionless predicate issue.</para>
            </section>
            <section>
                <title>Applicability</title>
                <section>
                    <title>Applies to</title>
                    <para>This pattern applies, among others, to the following scenarios:<orderedlist>
                            <listitem>
                                <para>Match patterns with predicates based on properties of
                                    descendant nodes.</para>
                            </listitem>
                        </orderedlist></para>
                </section>
                <section>
                    <title>Does not apply to</title>
                    <para>This pattern does not apply to the following scenarios:<orderedlist>
                            <listitem>
                                <para>Match patterns with predicates based on the following-sibling
                                    or preceding-sbiling axes;</para>
                            </listitem>
                            <listitem>
                                <para>Match patterns with predicates based on the following or
                                    preceding axes.</para>
                            </listitem>
                        </orderedlist></para>
                </section>
            </section>
            <section>
                <title>Consequences</title>
                <para>Applying this pattern has the following consequences:<orderedlist>
                        <listitem>
                            <para>The decision-tree must imperatively be written by hand, instead of
                                letting the processor define the logic for you, which is the normal
                                operation mode with template based matching.</para>
                        </listitem>
                        <listitem>
                            <para>Tricky to get right when multiple template rules exist that
                                process the same element. In such cases, it is better to use
                                windowed streaming, or, if that is not an option, forking.</para>
                        </listitem>
                    </orderedlist></para>
            </section>
            <section>
                <title>Implementation</title>
                <para>Refactor your original code by applying the following steps in order:<orderedlist>
                        <listitem>
                            <para>Introduce a streamable mode.</para>
                        </listitem>
                        <listitem>
                            <para>Remove the delete-template and the predicate in the
                                match-pattern.</para>
                        </listitem>
                        <listitem>
                            <para>Create a copy of the node.</para>
                        </listitem>
                        <listitem>
                            <para>Rewrite the decision logic of the predicate inside the template,
                                or apply templates on the copy.</para>
                        </listitem>
                    </orderedlist></para>
                <section>
                    <title>Example</title>
                    <para>If we apply these three refactoring rules to our original example, we end
                        up with the following code:
                        <programlisting>&lt;!-- (1) change the mode to streamable --&gt;
&lt;xsl:mode streamable="yes" /&gt;

&lt;!-- (2) remove the predicate --&gt;
&lt;xsl:template match="para" mode="streaming"&gt;
  &lt;!-- (3) create a copy of the node --&gt;
  &lt;xsl:variable name="copy"
    select="copy-of(.)" /&gt;
  &lt;!-- (4) rewrite the decision logic --&gt;
  &lt;xsl:copy-of
    select="$copy[descendant::emphasis]" /&gt;
&lt;/xsl:template&gt;

&lt;!-- (2) remove the delete-template --&gt;</programlisting></para>
                    <para>After applying this pattern, we have inlined the decision-logic, resulting
                        in a template body with one downward select to create a copy of the current node<footnote>
                            <para>If the copy will be too large, use the first pattern to preprocess
                                it to do a modified windowed streaming approach.</para>
                        </footnote>, which is streamable, because any subesequent processing on this
                        copy will be grounded, and therefor allowed during streaming.</para>
                    <para>This streaming pattern applies to any non-motionless predicate that, after
                        rewriting it as (something similar as) above, ends up with a maximum of one
                        downward select per template. If you end up with multiple downward selects
                        after rewriting, then also apply the following pattern, <emphasis role="italic">Instructions with multiple downward
                        selects</emphasis>.</para>
                </section>
            </section>
        </section>
        <section xml:id="paper-25_multiple_downward">
            <title>Instructions with multiple downward selects</title>
            <section>
                <title>Intent</title>
                <para>You have an instruction with multiple downward selects in document order and
                    want to make it streamable.</para>
            </section>
            <section>
                <title>Level</title>
                <para>Easy: follows a commong refactoring pattern from the XSLT 2.0 community.
                    Streamability level: full.</para>
            </section>
            <section>
                <title>Motivation</title>
                <para>Consider the following
                    example:<programlisting>&lt;xsl:template match="address"&gt;
  &lt;span&gt;&lt;xsl:value-of select="street" /&gt;&lt;/span&gt;
  &lt;span&gt;&lt;xsl:value-of select="number" /&gt;&lt;/span&gt;
  &lt;xsl:apply-templates select="state | country" /&gt;
&lt;/xsl:template&gt;
</programlisting></para>
                <para>This template is not streamable, because it violates <xref linkend="paper-25_rule1"/>,
                    it has multiple downward selects, here with the select expressions
                        <code>street</code>, <code>number</code> and <code>state | country</code>. </para>
            </section>
            <section>
                <title>Applicability</title>
                <section>
                    <title>Applies to</title>
                    <para>This pattern applies to the following scenarios:<orderedlist>
                            <listitem>
                                <para>The body of any instruction that has multiple downward selects
                                    in document order;</para>
                            </listitem>
                            <listitem>
                                <para>The body of a streamable stylesheet function having multiple
                                    downward selects in document order;</para>
                            </listitem>
                            <listitem>
                                <para>The body of a template declaration having multiple downward
                                    selects in document order.</para>
                            </listitem>
                        </orderedlist></para>
                </section>
                <section>
                    <title>Does not apply to</title>
                    <para>This pattern does not apply to:<orderedlist>
                            <listitem>
                                <para>Function-calls that contain multiple downward selects;</para>
                            </listitem>
                            <listitem>
                                <para>Single expressions with multiple downward selects;</para>
                            </listitem>
                            <listitem>
                                <para>Instructions with multiple downward selects that are not in
                                    document order, see <xref linkend="paper-25_multi-downward-out-of"/>.</para>
                            </listitem>
                        </orderedlist></para>
                </section>
            </section>
            <section>
                <title>Consequences</title>
                <para>Applying this pattern has the following consequences:<orderedlist>
                        <listitem>
                            <para>After rewriting the body, its coherency may be harder to
                                understand and thus harder to maintain.</para>
                        </listitem>
                    </orderedlist></para>
            </section>
            <section>
                <title>Implementation</title>
                <para>Refactor your original code by applying the following steps in order:<orderedlist>
                        <listitem>
                            <para>Introduce a streamable mode with
                                    <code>on-no-match="deep-skip"</code><footnote>
                                    <para><code>deep-skip</code> skips non-matching nodes without
                                        processing their children.</para>
                                </footnote>;</para>
                        </listitem>
                        <listitem>
                            <para>Replace the body of your instruction with a single
                                    <code>xsl:apply-templates</code>;</para>
                        </listitem>
                        <listitem>
                            <para>Add matching templates for the individual elements.</para>
                        </listitem>
                    </orderedlist></para>
                <section>
                    <title>Example</title>
                    <para>Applying these three refactoring rules to our original example, we end up
                        with the following code:
                        <programlisting>&lt;!-- (1) change the mode to streamable --&gt;
&lt;xsl:mode streamable="yes"
          on-no-match="deep-skip" /&gt;

&lt;!-- (1) change the mode to streamable --&gt;
&lt;xsl:template match="address" mode="streaming"&gt;
  &lt;!-- (2) replace the body with
           a single apply-templates --&gt;
  &lt;xsl:apply-templates select="*" mode="#current"/&gt;
&lt;/xsl:template&gt;

&lt;!-- (3) add matching templates
         for each element --&gt;
&lt;xsl:template match="street | number"
              mode="streamable"&gt;
  &lt;span&gt;&lt;xsl:value-of select="." /&gt;&lt;/span&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="state | country"
              mode="streamable"&gt;
  &lt;!-- details left out --&gt;
&lt;/xsl:template&gt;</programlisting></para>
                    <para>This pattern is perhaps the most common pattern with streaming: take any
                        given instruction with too many downward selects and split it up in smaller
                        pieces to make it streamable. Most people will be familiar with this
                        pattern, because it does not introduce any new concepts, in fact, it is a
                        common refactoring method in existing stylesheets.</para>
                </section>
            </section>
        </section>
        <section xml:id="paper-25_multi-downward-out-of">
            <title>Instructions with multiple downward selects out of
                document order</title>
            <section>
                <title>Intent</title>
                <para>You have an instruction with multiple downward selects that do not follow the
                    input document order and want to make it streamable.</para>
            </section>
            <section>
                <title>Level</title>
                <para>Advanced: introduces a new concept, forking. Streamability level: full.</para>
            </section>
            <section>
                <title>Motivation</title>
                <para>Consider the following
                    example:<programlisting>&lt;xsl:template match="address"&gt;
  &lt;!-- number first --&gt;
  &lt;span&gt;&lt;xsl:value-of select="number" /&gt;&lt;/span&gt;
  &lt;span&gt;&lt;xsl:value-of select="street" /&gt;&lt;/span&gt;
  &lt;xsl:apply-templates select="state | country" /&gt;
&lt;/xsl:template&gt;
</programlisting></para>
                <para>Similar to <xref linkend="paper-25_multiple_downward"/>, this template is not
                    streamable, because it violates <xref linkend="paper-25_rule1"/>, it has multiple
                    downward selects, again with the select expressions <code>street</code>,
                        <code>number</code> and <code>state | country</code>. Note, however, an
                    important difference with the previous design pattern: in this case, the order
                    of the selected elements does not match the document order of the input
                    document.</para>
            </section>
            <section>
                <title>Applicability</title>
                <section>
                    <title>Applies to</title>
                    <para>This pattern applies to the following scenarios:<orderedlist>
                            <listitem>
                                <para>The body of any instruction that has multiple downward selects
                                    in any order;</para>
                            </listitem>
                            <listitem>
                                <para>The body of a streamable stylesheet function having multiple
                                    downward selects in any order;</para>
                            </listitem>
                            <listitem>
                                <para>The body of a template declaration having multiple downward
                                    selects in any order.</para>
                            </listitem>
                        </orderedlist></para>
                </section>
                <section>
                    <title>Does not apply to</title>
                    <para>This pattern does not apply to:<orderedlist>
                            <listitem>
                                <para>Function-calls that contain multiple downward selects;</para>
                            </listitem>
                            <listitem>
                                <para>Single expressions with multiple downward selects;</para>
                            </listitem>
                        </orderedlist></para>
                </section>
            </section>
            <section>
                <title>Consequences</title>
                <para>Applying this pattern has the following consequences:<orderedlist>
                        <listitem>
                            <para>The instruction <code>xsl:fork</code> has no effect on the result,
                                it can be hard for programmers to understand why it is introduced
                                and the temptation to remove it at a later stage, because "it does
                                nothing special" can be big.</para>
                        </listitem>
                        <listitem>
                            <para>Code quickly gets messy, because nesting gets two levels deeper
                                with each fork.</para>
                        </listitem>
                    </orderedlist></para>
            </section>
            <section>
                <title>Implementation</title>
                <para>Refactor your original code by applying the following steps in order:<orderedlist>
                        <listitem>
                            <para>Introduce a streamable mode;</para>
                        </listitem>
                        <listitem>
                            <para>Wrap each downward select in an <code>xsl:fork</code>
                                instruction.</para>
                        </listitem>
                    </orderedlist></para>
                <section>
                    <title>Example</title>
                    <para>Applying these two refactoring rules to our original example, we end up
                        with the following code:
                        <programlisting>&lt;!-- (1) change the mode to streamable --&gt;
&lt;xsl:mode streamable="yes" /&gt;

&lt;!-- (1) change the mode to streamable --&gt;
&lt;xsl:template match="address" mode="streamable"&gt;
  &lt;!-- (2) wrap in xsl:fork --&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:sequence&gt;
      &lt;span&gt;&lt;xsl:value-of select="number" /&gt;&lt;/span&gt;
    &lt;/xsl:sequence&gt;
    &lt;xsl:sequence&gt;
      &lt;span&gt;&lt;xsl:value-of select="street" /&gt;&lt;/span&gt;
    &lt;/xsl:sequence&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:apply-templates
        select="state | country" /&gt;
    &lt;/xsl:sequence&gt;
  &lt;/xsl:fork&gt;
&lt;/xsl:template&gt;</programlisting></para>
                    <para>As explained in <xref linkend="paper-25_rule10"/>, forking is a technique that has
                        no semantic meaning, it merely tells the processor to process the streaming
                        input from this moment on using multiple reading heads. Introducing
                            <code>xsl:fork</code> in code allows the programmer to write a sequence
                        of <code>xsl:sequence</code> elements, of which the body, or select
                        attribute, can each contain a single downward select expression.</para>
                    <para>This pattern opens up a lot of possibilities. It is a common scenario to
                        change the order in which elements are output. Using <code>xsl:fork</code>
                        makes this easier to achieve using streaming<footnote>
                            <para>Other ways of achieving the same result are not so trivial, unless
                                you fallback to creating a copy of the node and process that copy
                                using non-streaming templates, as in the first pattern.</para>
                        </footnote>.</para>
                </section>
            </section>
        </section>
        <section xml:id="paper-25_preceding_sibling">
            <title>Expressions with the preceding- or following-sibling
                axes</title>
            <section>
                <title>Intent</title>
                <para>You have an expression that involves iterating over the preceding-sibling or
                    following-sibling nodes<footnote>
                        <para>The axes following, preceding, following-sibling and preceding-sibling
                            are part of the group of <emphasis role="italic">forbidden streaming
                                paths</emphasis>, they cannot operate on a streaming node, if they
                            do, the streamability analysis will deem them free-ranging. They are
                            allowed, however, on grounded nodes, i.e., nodes that do not belong to a
                            streamed document.</para>
                    </footnote>.</para>
            </section>
            <section>
                <title>Level</title>
                <para>Advanced, involves streamed grouping. Streamability level: full.</para>
            </section>
            <section>
                <title>Motivation</title>
                <para>In flat-to-hieararchical scenarios it is still quite common to use the
                    following-sibling axis. Consider the following input
                    document:<programlisting language="xml">&lt;books&gt;
    &lt;book type="classic"/&gt;
    &lt;title&gt;Don Quixote&lt;/title&gt;
    &lt;author&gt;Micuel De Cervantes&lt;/author&gt;
    &lt;book type="classic"/&gt;
    &lt;title&gt;Pilgrim's Progress&lt;/title&gt;
    &lt;author&gt;John Bunyan&lt;/author&gt;
    &lt;book type="classic"/&gt;
    &lt;title&gt;Robinson Crusoe&lt;/title&gt;
    &lt;author&gt;Daniel Defoe&lt;/author&gt;        
&lt;/books&gt;</programlisting>and
                    we would like to turn this into a nested structure, where <code>title</code> and
                        <code>author</code> are part of the <code>book</code> element. One way of
                    doing that
                    is:<programlisting>&lt;xsl:template match="/books"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="book" /&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="book"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:copy-of select="@*" /&gt;
    &lt;xsl:apply-templates
      select="following-sibling::title[1]" /&gt;
    &lt;xsl:apply-templates
      select="following-sibling::author[1]" /&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="title | author"&gt;
  &lt;xsl:copy-of select="." /&gt;
&lt;/xsl:template&gt;</programlisting></para>
                <para>In practice, usage of the following sibling and preceding sibling axis has
                    been getting less and less attention since the dawn of XSLT 2.0, which
                    introduced grouping<footnote>
                        <para>It has not entirely disappeared, a recent thread on StackOverflow
                            discusses this coding pattern, see <link xl:href="http://stackoverflow.com/questions/8961220">XPath to select
                                contiguous elements</link>.</para>
                    </footnote>. One of the reasons we don't see much of the sibling axis is that
                    sibling recursion is quite hard to get right in XSLT 2.0 and up<footnote>
                        <para>In XSLT 1.0, if an axis selected multiple nodes, only the first one
                            was actually selected. In XSLT 2.0, by default, <emphasis role="italic">all nodes on an axis</emphasis> are selected in path expressions.
                            As a result, sibling recursion in XSLT 1.0, which typically relied on
                            this feature, was not compatible and had to be rewritten for XSLT
                            2.0.</para>
                    </footnote> and because most coding patterns are just easier to accomplish and
                    understand with <code>xsl:for-each-group</code> with <code>group-adjacent</code>
                    or <code>group-starting-with</code>, as is explained in
                        <xref linkend="paper-25_MKAY08"/>, page 116.</para>
                <para>The output of the above template would be the
                    following:<programlisting language="xml">&lt;books&gt;
   &lt;book type="classic"&gt;
      &lt;title&gt;Don Quixote&lt;/title&gt;
      &lt;author&gt;Micuel De Cervantes&lt;/author&gt;
   &lt;/book&gt;
   &lt;book type="classic"&gt;
      &lt;title&gt;Pilgrim's Progress&lt;/title&gt;
      &lt;author&gt;John Bunyan&lt;/author&gt;
   &lt;/book&gt;
   &lt;book type="classic"&gt;
      &lt;title&gt;Robinson Crusoe&lt;/title&gt;
      &lt;author&gt;Daniel Defoe&lt;/author&gt;
   &lt;/book&gt;
&lt;/books&gt;
</programlisting></para>
            </section>
            <section>
                <title>Applicability</title>
                <section>
                    <title>Applies to</title>
                    <para>This pattern applies to the following scenarios:<orderedlist>
                            <listitem>
                                <para>Expressions that use the preceding-sibling or the
                                    following-sibling axes.</para>
                            </listitem>
                            <listitem>
                                <para>Can sometimes also be applied to patterns that use these
                                    axes.</para>
                            </listitem>
                        </orderedlist></para>
                </section>
                <section>
                    <title>Does not apply to</title>
                    <para>This pattern does not apply to:<orderedlist>
                            <listitem>
                                <para>Expressions with the following and preceding axes.</para>
                            </listitem>
                        </orderedlist></para>
                </section>
            </section>
            <section>
                <title>Consequences</title>
                <para>Applying this pattern has the following consequences:<orderedlist>
                        <listitem>
                            <para>It makes your code more readable and easier to maintain<footnote>
                                    <para>That is a first! Usually, refactoring code to fit a
                                        streaming scenario results in less readable code, but this
                                        pattern actually makes it more readable and maintainable.
                                        Perhaps you should have applied this pattern already, even
                                        before you started streaming.</para>
                                </footnote>.</para>
                        </listitem>
                        <listitem>
                            <para>Streamed grouping can be hard to grasp and to get right, which in
                                more complex scenario may require a significant endeavor.</para>
                        </listitem>
                    </orderedlist></para>
            </section>
            <section>
                <title>Implementation</title>
                <para>Refactor your original code by applying the following steps in order:<orderedlist>
                        <listitem>
                            <para>Introduce a streaming mode.</para>
                        </listitem>
                        <listitem>
                            <para>Replace the sibling recursion pattern with
                                    <code>xsl:for-each-group</code><footnote>
                                    <para>This is not always trivial to get right, but many sibling
                                        recursion patterns can be rewritten with
                                            <code>group-starting-with</code> or with
                                            <code>group-adjacent</code>.</para>
                                </footnote>.</para>
                        </listitem>
                        <listitem>
                            <para>If needed, adjust the resulting code using previous patterns, to
                                make it streamable.</para>
                        </listitem>
                    </orderedlist></para>
                <section>
                    <title>Example</title>
                    <para>Applying these three refactoring rules to our original example, we end up
                        with the following code:
                        <programlisting>&lt;!-- (1) introduce a streamable mode --&gt;
&lt;xsl:mode streamable="yes" /&gt;

&lt;xsl:template match="/books"&gt;
  &lt;xsl:copy&gt;
    &lt;!-- (2) rewrite the sibling recursion --&gt;
    &lt;xsl:for-each-group select="*"
                        group-starting-with="book"&gt;
      &lt;xsl:copy&gt;
        &lt;!-- (3) streamable body --&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        &lt;xsl:copy-of select="current-group()[
                       position() &gt; 1]" /&gt;
      &lt;/xsl:copy&gt;
    &lt;/xsl:for-each-group&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</programlisting></para>
                    <para>This streaming pattern follows a typical XSLT 3.0 scenario for grouping.
                        By applying grouping we can get rid of the <code>following-sibling</code>
                        axis steps. In this case, it sufficed to use
                            <code>group-starting-with</code>, which takes a motionless pattern as
                        seen from <xref linkend="paper-25_rule7"/>. The <code>select</code>-statement is
                        obvious and allowed in streaming (it selects children).</para>
                    <para>Let us have a look at the individual parts. The nesting applied here
                        follows <xref linkend="paper-25_rule2"/>, each construct in it has a maximum of one
                        downward expression:<itemizedlist>
                            <listitem>
                                <para>The <code>xsl:copy</code> instruction is motionless if it does
                                    not have a <code>select</code> statement, however we still need
                                    to look at its sequence constructor, as per <emphasis role="italic">Rule Two</emphasis>.</para>
                            </listitem>
                            <listitem>
                                <para>The <code>xsl:for-each-group</code> instruction is consuming,
                                    it contains one downward select. However, as we have learned in
                                        <emphasis role="italic">Rule Two</emphasis>, it is also a
                                    focus-changing construct. This means that the sequence
                                    constructor inside it can have yet another downward select
                                    expression. Because we already established that the pattern in
                                        <code>group-starting-with</code> is motionless, this does
                                    not count towards the limit of one, we can have as many
                                    motionless expressions as we want.</para>
                            </listitem>
                            <listitem>
                                <para>The second <code>xsl:copy</code> instruction is again
                                    motionless on itself, but we need to check its sequence
                                    constructor.</para>
                            </listitem>
                            <listitem>
                                <para>The first <code>xsl:copy-of</code> instruction is motionless,
                                    remember that visiting the attribute axis is always allowed, see
                                        <xref linkend="paper-25_rule3"/>.</para>
                            </listitem>
                            <listitem>
                                <para>The second <code>xsl:copy-of</code> instruction is consuming.
                                    It consumes the <code>fn:current-group</code> and selects all
                                    elements except the first. In most cases, using or referencing
                                    the current group will count as a downward expression, as such
                                    it is not legal to have more than one usage of the expression,
                                    nor can you use the expression in an inner loop or loop expression<footnote>
                                        <para>The public <link xl:href="http://www.w3.org/TR/xslt-30/#information-about-group">Last Call WD in Section 19.8.8.5</link>
                                            specifically disallowed <code>fn:current-group</code> in
                                            streaming. After several bug reports and extensive
                                            research to assess whether allowing this function in
                                            streaming proved doable, a proposal by Michael Kay was
                                            accepted through <link xl:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=24510">XSLT 3.0 Bug 24510</link>. See also <link xl:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=23391">XSLT 3.0 Bug 23391</link>, <link xl:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=24342">24342</link>, <link xl:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=24317">24317</link> (talks about a limitaion in grouped
                                            streaming), <link xl:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=24509">24509</link>, <link xl:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=24556">24556</link>, <link xl:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=24455">24455</link>. The resolution is publicly available
                                            as an attachment to <link xl:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=24510#c9">Bug 24510, comment 9</link>, which is a good
                                            starting point.</para>
                                    </footnote>. </para>
                            </listitem>
                            <listitem>
                                <para>Note that, similar to the explanation in the first streaming
                                    pattern, it is not possible to combine these two
                                        <code>xsl:copy</code> instructions into one with a union expression<footnote>
                                        <para>Which is only partially true, you could do it by
                                            creating an inline copy of the attributes, such as
                                                <code>&lt;xsl:copy-of select="copy-of(@*) |
                                                current-group()[position() &gt; 2]" /&gt;</code>.</para>
                                    </footnote>.</para>
                            </listitem>
                            <listitem>
                                <para>Note that using the <code>fn:position</code> function is
                                    allowed and motionless in any expression. It only has special
                                    meaning in patterns, where it is not allowed in a top-level
                                    predicate.</para>
                            </listitem>
                        </itemizedlist></para>
                </section>
            </section>
        </section>
        <section xml:id="paper-25_preceding_axis">
            <title>Expressions using the preceding axis</title>
            <section>
                <title>Intent</title>
                <para>You have an expression that uses the preceding axis and want to make it
                    streamable.</para>
            </section>
            <section>
                <title>Level</title>
                <para>Advanced: uses accumulators<footnote>
                        <para>If possible, it is <emphasis role="italic">much</emphasis> easier to
                            solve this pattern using windowed streaming, by creating a copy of the
                            parent node, which allows you to use any expression. However, that only
                            works if the <emphasis role="italic">distance</emphasis> between the
                            preceding node and its possible usages is small and fits in a windowed
                            copy.</para>
                    </footnote><footnote>
                        <para>Sometimes it is possible to rewrite such axes in terms of child axes,
                            tunneled parameters or other ways, that would be streamable. If such a
                            solution exists, it should take preference over using
                            accumulators.</para>
                    </footnote>. Steamability level: full.</para>
            </section>
            <section>
                <title>Motivation</title>
                <para>Suppose you want to keep a tracking word count per paragraph that shows all
                    preceding words. You could code that as follows (though on large documents this
                    will be highly
                    inefficient):<programlisting>&lt;xsl:template match="text"&gt;
  &lt;xsl:apply-templates /&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="para" use-when="false()"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:attribute
      name="words-sofar"
      select="count(
                preceding::text()/
                tokenize(., ' ')
              )" /&gt;
    &lt;xsl:copy-of select="text()"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</programlisting></para>
                <para>The code above is so trivial that I will leave out the flat input XML and
                    output XML. It simply counts all the words up until the current paragraph and
                    adds this count to the <code>para</code> element as an attribute. To make this
                    streamable, we will have to use accumulators<footnote>
                        <para>This coding problem can also be solved using tunneled parameters, and
                            in fact, it is believed that most accumulator-scenario can be expressed
                            with tunneled parameters, however, it can get very unwieldy to keep
                            track of tunneled parameters across all templates in a real-world
                            scenario. Accumulators are a cleaner way to do this.</para>
                    </footnote>.</para>
            </section>
            <section>
                <title>Applicability</title>
                <section>
                    <title>Applies to</title>
                    <para>This pattern applies to the following scenarios:<orderedlist>
                            <listitem>
                                <para>Path expressions using the following<footnote>
                                        <para>It applies only to the following axis if the
                                            stylesheet can be rewritten using the reverse of that
                                            axis, because accumulator <emphasis role="italic">cannot</emphasis> look forward, they can only
                                            remember "what has been processed so far".</para>
                                    </footnote> or preceding axes.</para>
                            </listitem>
                            <listitem>
                                <para>Path expressions using the sibling axes<footnote>
                                        <para>Prefer the previous streaming pattern, where a sibling
                                            recursion is rewritten using streamed grouping.</para>
                                    </footnote>.</para>
                            </listitem>
                            <listitem>
                                <para>Any free-ranging expression that cannot be made streamable
                                    using any of the other streaming patterns.</para>
                            </listitem>
                            <listitem>
                                <para>Any place where you need to keep (the equivalent of) a running total<footnote>
                                        <para>For instance, multi-level section numbering is a
                                            typical scenario for accumulators. An example, including
                                            explanation on how it works with accumulators, is in
                                                <link xl:href="https://www.w3.org/XML/Group/qtspecs/specifications/xslt-30/html/Overview.html#accumulator-examples">Section 18.2.8, Examples of Accumulators, in the
                                                XSL Transformations 3.0 Specification</link>.</para>
                                    </footnote>.</para>
                            </listitem>
                        </orderedlist></para>
                </section>
                <section>
                    <title>Does not apply to</title>
                    <para>This pattern does not apply to:<orderedlist>
                            <listitem>
                                <para>Scenarios where information ahead is required.</para>
                            </listitem>
                            <listitem>
                                <para>Scenarios that can be rewritten without using accumulators
                                    (this has preference).</para>
                            </listitem>
                            <listitem>
                                <para>Scenarios that cannot be expressed as a sequence of motionless
                                    expressions upon processed nodes<footnote>
                                        <para>Accumulators can only operate on nodes with a
                                            motionless expression.</para>
                                    </footnote>.</para>
                            </listitem>
                        </orderedlist></para>
                </section>
            </section>
            <section>
                <title>Consequences</title>
                <para>Applying this pattern has the following consequences:<orderedlist>
                        <listitem>
                            <para>May dramatically increase complexity by having to use
                                accumulators.</para>
                        </listitem>
                        <listitem>
                            <para>Need to keep track of visiting of passed nodes, which can be hard
                                to get right<footnote>
                                    <para>Using maps makes this task a tad easier though, maps are a
                                        new type introduced in XSLT 3.0.</para>
                                </footnote>.</para>
                        </listitem>
                    </orderedlist></para>
            </section>
            <section>
                <title>Implementation</title>
                <para>Refactor your original code by applying the following steps in order:<orderedlist>
                        <listitem>
                            <para>Introduce a streamable mode;</para>
                        </listitem>
                        <listitem>
                            <para>Create a streamable accumulator.</para>
                        </listitem>
                        <listitem>
                            <para>Add the appropriate accumulator rules to add properties to visited
                                nodes.</para>
                        </listitem>
                        <listitem>
                            <para>Change the offending expression to use the accumulator expression
                                instead.</para>
                        </listitem>
                    </orderedlist></para>
                <section>
                    <title>Example</title>
                    <para>Applying these four refactoring rules to our original example, we end up
                        with the following code:
                        <programlisting>&lt;!-- (1) introduce a streamable mode --&gt;
&lt;xsl:mode streamable="yes" /&gt;

&lt;!-- (2) create a streamable accumulator --&gt;
&lt;xsl:accumulator name="count-words"
                 as="xs:integer"
                 initial-value="0"
                 streamable="yes"&gt;

  &lt;!-- (3) add appropriate
           rules to decorate nodes --&gt;
  &lt;xsl:accumulator-rule
    match="text()[parent::para]"
    phase="start"
    new-value="$value + count(./tokenize(.,' '))"/&gt;

&lt;/xsl:accumulator&gt;

&lt;xsl:template match="text"&gt;
  &lt;xsl:apply-templates /&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="para"&gt;
  &lt;xsl:copy&gt;
    &lt;!-- (4) adjust the expression
             to use the accumulator --&gt;
    &lt;xsl:attribute 
      name="words-sofar" 
      select="accumulator-before('count-words')" /&gt;

    &lt;xsl:copy-of select="text()"/&gt;
  &lt;/xsl:copy&gt;        
&lt;/xsl:template&gt;
</programlisting></para>
                    <para>Before we explain the code, let us first look at what accumulators are and
                        how they can be applied:</para>
                    <para>An accumulator is best seen as a calculated property, or decoration, or
                        function of a node: it can "attach" a value to a node that is made available
                        through the <code>fn:accumulator-before</code> and
                            <code>fn:accumulator-after</code> functions<footnote>
                            <para>For more information on accumulators and examples, see <link xl:href="http://www.w3.org/TR/xslt-30/#accumulators">Section
                                    18.2 in XSL Transformations 3.0</link>.</para>
                        </footnote>. Accumulators are processed for <emphasis role="italic">each</emphasis> node that is processed in a streamable way<footnote>
                            <para>Provided its attribute <code>streamable</code> is set to
                                    <code>yes</code>, otherwise, it applies to any non-streaming
                                document.</para>
                        </footnote>, regardless of their source<footnote>
                            <para>The XSLT 3.0 Working Group is considering a proposal to limit an
                                accumulator to a source document to prevent accumulators taking up
                                too much processing time overhead. The status of this proposal can
                                be tracked through <link xl:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=24547">XSLT 3.0 Bug 24547</link>, read from <link xl:href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=24547#c6">comment#6</link>.</para>
                        </footnote>. Streamable accumulators must be motionless and they cannot
                        return streamed nodes. </para>
                    <para>An accumulator consists of three parts:<orderedlist>
                            <listitem>
                                <para>The top-level accumulator declaration
                                        <code>xsl:accumulator</code>, containing the name, the
                                    initial value, and whether or not is applies to streaming
                                    documents.</para>
                            </listitem>
                            <listitem>
                                <para>One or more accumulator rules, defined as children
                                        <code>xsl:accumulator-rule</code> elements of the
                                    accumulator declaration, which each defines a new value for the
                                    accumulator, whose calculation can be based on the previous
                                    value, obtainable through the reserved variable
                                        <code>$value</code>. An accumulator rule applies to a
                                    matching pattern, which follows rules equal to a match-pattern
                                    of a template<footnote>
                                        <para>With two exceptions: you cannot match an attribute
                                            (you can reach out to attributes from an element with a
                                            motionless expression anyway), and you cannot match a
                                            namespace node (functions such as
                                                <code>in-scope-namespaces</code> are motionless, use
                                            them instead).</para>
                                    </footnote>. There are two types of rules:<itemizedlist>
                                        <listitem>
                                            <para><code>phase="start"</code>, also called an
                                                  <emphasis role="italic">accumulator-before
                                                  rule</emphasis> applies the accumulator rule when
                                                the processor visits the opening tag<footnote>
                                                  <para>This is correct: it is the only declaration
                                                  that can depend on start- and end-tags, though
                                                  these terms are not officially used in the
                                                  specification, because it applies more generally
                                                  to any node.</para>
                                                </footnote>, or beginning of the matching node. This
                                                means that, if you use the function
                                                  <code>fn:accumulator-before</code> upon processing
                                                such node, it will return the new value just
                                                calculated in that rule. This is called the
                                                  <emphasis role="italic">pre-descent
                                                  value</emphasis>.</para>
                                            <para>You can request a pre-descent value only <emphasis role="italic">before</emphasis> a consuming
                                                instruction, or, if the body of a construct does not
                                                contain a consuming instruction, anywhere in that
                                                body.</para>
                                        </listitem>
                                        <listitem>
                                            <para><code>phase="end"</code>, also called an <emphasis role="italic">accumulator-after rule</emphasis>,
                                                applies the accumulator rule when the processor
                                                visits the closing tag, or end of the matching node.
                                                This means that, if you use the function
                                                  <code>fn:accumulator-after</code>
                                                <emphasis role="italic">after</emphasis> you are
                                                done visiting that node, it will contain the new
                                                value calculated by the matching accumulator-after
                                                rule. This is called the <emphasis role="italic">post-descent value</emphasis>.</para>
                                            <para>You can request a post-descent value only
                                                  <emphasis role="italic">after</emphasis> a
                                                consuming instruction, or, if the body of a
                                                construct does not contain a consuming instruction,
                                                anywhere in that body.</para>
                                        </listitem>
                                    </itemizedlist></para>
                            </listitem>
                            <listitem>
                                <para>Zero or more usages of the accumulator, by the functions
                                        <code>fn:accumulator-before</code> and
                                        <code>fn:accumulator-after</code>, which take one parameter
                                    of type <code>xs:string</code>, whose value must match an
                                    existing accumulator name. When you can use which is described
                                    under the previous item.</para>
                            </listitem>
                        </orderedlist></para>
                    <para>Now that the essence of accumulators is clear, we can take a fresh look at
                        the code. The streamable accumulator declared at the root and going by the
                        name <code>count-words</code> and an initial value of <code>0</code> has one
                        accumulator rule:<itemizedlist>
                            <listitem>
                                <para><emphasis role="italic">Accumulator-before rule:</emphasis> it
                                    defines the <code>phase</code> as <code>start</code>, while this
                                    is the default, it is clearer to specify it explicitly.</para>
                            </listitem>
                            <listitem>
                                <para>The match pattern is <code>text()[parent::para]</code>. This
                                    means that when this pattern matches any node, regardless of
                                    existing <code>xsl:apply-templates</code> instructions<footnote>
                                        <para>Accumulators are global. They ignore the filter
                                            present in the <code>on-no-match</code> attribute, even
                                            if it is defined as <code>deep-skip</code>. If you want
                                            to skip nodes, you need to create a motionless pattern
                                            in the accumulator rules that does so. The only
                                            declaration that can have effect on accumulators is
                                            whitespace stripping, which happens prior to applying
                                            accumulators.</para>
                                    </footnote> or <code>xsl:for-each</code> loops, it will update
                                    the accumulator value attached to that node. Any accumulator
                                    matches twice, once at the start and once at the end of visiting
                                    a node (after processing its children). Left out phases default
                                    to leaving the current value unchanged.</para>
                                <para>This pattern makes sure that we only match text nodes that are
                                    a child of <code>para</code> elements, which matches the
                                    original program listing. We cannot match <code>para</code>
                                    elements here, because then attempting to count the
                                        <code>text()</code> children would be considered
                                    non-motionless and is illegal in a streaming accumulator.</para>
                            </listitem>
                            <listitem>
                                <para>The <code>new-value</code> attribute does what the
                                        <code>preceding::text()</code> expression did for us in the
                                    original code. At each visit of a text node, it adds the total
                                    count of the words to the previous count of the words.</para>
                                <para>Allowing an expression on a text node may seem like a
                                    consuming expression and therefore not streamable. However, as
                                    we have seen in the first example in <xref linkend="paper-25_rule9"/>,
                                    expressions that consume childless nodes are considered
                                    motionless.</para>
                            </listitem>
                        </itemizedlist></para>
                    <para>In the matching template for the <code>para</code> element, the code was
                        changed to use this accumulator instead of the <code>following::</code>
                        expression. This works, because on each time this template is processed, the
                        current node will be a <code>para</code> element, and its children are not
                        yet processed, which means that the running total on the first visit will be
                            <code>0</code> (zero). Then, upon the call to <code>text()</code> in the
                            <code>xsl:copy-of</code> instruction, the text node is processed and the
                        running total is updated, which is reflected upon the next visit of the
                        template. And so on, until the last <code>para</code> is visited.</para>
                    <para>You might wonder how we can change this behavior and have the running
                        total per paragraph include the count of the current paragraph, in other
                        words, the first count should not be zero, but the total of that
                        paragraph.</para>
                    <para>To achieve that, we need to make a few changes, but it is not as hard as
                        it might seem at first:<itemizedlist>
                            <listitem>
                                <para>You might be tempted to change the accumulator rule phase to
                                        <code>phase="end"</code>, but this is not required in this
                                    scenario, because it operates on a childness node. That means
                                    that when the text node is processed, both the
                                        <code>fn:accumulator-before</code> and
                                        <code>fn:accumulator-after</code> functions can used within
                                    the matching template.</para>
                            </listitem>
                            <listitem>
                                <para>Change the matching template to match the text node instead.
                                    Upon visiting the text node, the calculated value is available.
                                    This is different from our previous situation, where we
                                    requested the calculated value <emphasis role="italic">before</emphasis> the text node was visited. There is no
                                        <emphasis role="italic">before</emphasis> and <emphasis role="italic">after</emphasis> for a text node.</para>
                            </listitem>
                            <listitem>
                                <para>Add the <code>parent::para</code> to text-matching template,
                                    otherwise we also match unwanted text-nodes.</para>
                            </listitem>
                        </itemizedlist></para>
                    <para>The result of these changes looks as follows (only the changed parts are
                        shown):<programlisting>&lt;xsl:template match="para"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="text()" /&gt;
  &lt;/xsl:copy&gt;        
&lt;/xsl:template&gt;

&lt;xsl:template match="text()[parent::para]"&gt;
  &lt;xsl:attribute name="words-sofar"
    select="accumulator-before('count-words')" /&gt;
  &lt;xsl:copy-of select="."/&gt;
&lt;/xsl:template&gt;</programlisting></para>
                </section>
            </section>
        </section>
        <section xml:id="paper-25_lookaround">
            <title>Stylesheets requiring look-around</title>
            <section>
                <title>Intent</title>
                <para>You have a stylesheet with expressions that rely on preprocessing the input
                    tree and you want to make it streamable.</para>
            </section>
            <section>
                <title>Level</title>
                <para>Advanced, uses forking and multi-pass streaming. Streamability level: multi-pass<footnote>
                        <para>Not all scenarios can be forked, it depends on whether it is possible
                            to split processing where one part does not depend on intermittent
                            output of another part. In other words, the forking pattern only works
                            if you can process each part individually.</para>
                    </footnote>.</para>
            </section>
            <section>
                <title>Motivation</title>
                <para>Consider you have been given the following
                    input:<programlisting language="xml">&lt;expenses&gt;
  &lt;data date="2014-05-15"&gt;
    &lt;amount article="pencils"&gt;28.97&lt;/amount&gt;
    &lt;amount article="paper"&gt;42.90&lt;/amount&gt;
    &lt;amount article="clips"&gt;18.41&lt;/amount&gt;
    &lt;amount article="ink"&gt;143.93&lt;/amount&gt;
    &lt;amount article="staples"&gt;6.23&lt;/amount&gt;
  &lt;/data&gt;
  &lt;data date="2014-05-16"&gt;
    &lt;amount article="pencils"&gt;44.62&lt;/amount&gt;
    &lt;amount article="paper"&gt;154.34&lt;/amount&gt;
    &lt;amount article="clips"&gt;6.19&lt;/amount&gt;
    &lt;amount article="ink"&gt;219.07&lt;/amount&gt;
    &lt;amount article="staples"&gt;0.00&lt;/amount&gt;
  &lt;/data&gt;
  &lt;data date="2014-05-17"&gt;
    &lt;amount article="clips"&gt;38.02&lt;/amount&gt;
    &lt;amount article="ink"&gt;108.71&lt;/amount&gt;
    &lt;amount article="staples"&gt;11.84&lt;/amount&gt;
  &lt;/data&gt;
&lt;/expenses&gt;
</programlisting>and
                    your requirement is to calculate daily totals and what the daily percentage is
                    from the grand total, like
                    this:<programlisting language="xml">&lt;expenses&gt;
  &lt;data total="240.44" perc="29" date="2014-05-15"&gt;
    &lt;amount article="pencils"&gt;28.97&lt;/amount&gt;
    &lt;amount article="paper"&gt;42.90&lt;/amount&gt;
    &lt;amount article="clips"&gt;18.41&lt;/amount&gt;
    &lt;amount article="ink"&gt;143.93&lt;/amount&gt;
    &lt;amount article="staples"&gt;6.23&lt;/amount&gt;
  &lt;/data&gt;
  &lt;data total="424.22" perc="52" date="2014-05-16"&gt;
    &lt;amount article="pencils"&gt;44.62&lt;/amount&gt;
    &lt;amount article="paper"&gt;154.34&lt;/amount&gt;
    &lt;amount article="clips"&gt;6.19&lt;/amount&gt;
    &lt;amount article="ink"&gt;219.07&lt;/amount&gt;
    &lt;amount article="staples"&gt;0.00&lt;/amount&gt;
  &lt;/data&gt;
  &lt;data total="158.57" perc="19" date="2014-05-17"&gt;
    &lt;amount article="clips"&gt;38.02&lt;/amount&gt;
    &lt;amount article="ink"&gt;108.71&lt;/amount&gt;
    &lt;amount article="staples"&gt;11.84&lt;/amount&gt;
  &lt;/data&gt;
&lt;/expenses&gt;</programlisting>
                    With XSLT 2.0, one could achieve it using a stylesheet like the
                    following:<programlisting>&lt;xsl:template match="node() | @*"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="node() | @*" /&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="/expenses"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="node() | @*" /&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="data"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:attribute name="total"
      select="sum(amount)" /&gt;
    &lt;xsl:attribute name="perc"
      select="round(sum(amount) div
              sum(//amount) * 100)" /&gt;
    &lt;xsl:apply-templates select="node() | @*" /&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</programlisting></para>
                <para>On each visit of the the <code>data</code> element, we calculate the total of
                    that day and the average in respect to the grand total. The total of that day is
                    dependent of the children and the average is dependent on all
                        <code>amount</code> elements, and as such, at the moment of visiting the
                        <code>data</code> element, it requires (re)visiting all preceding and
                    following <code>amount</code> elements.</para>
                <para>Since looking around is not allowed in streaming, it is not immediately
                    obvious how to make this example streamable. The first thing that comes to mind
                    is using forking as in the <emphasis role="italic">out of document
                        order</emphasis> pattern above. But that does not help us much, because we
                    cannot store the result of one fork operation and use it in another for operation<footnote>
                        <para>This is intentional in the design of <code>xsl:fork</code>, forking
                            does not go over the input multiple times, instead, it visits each
                            streamed input node one time as with normal streaming, but processes it
                            multiple times, for each fork instruction.</para>
                    </footnote>.</para>
                <para>The streaming pattern discussed here will use an approach called multi-pass
                    streaming, where the input stream is processed multiple times. It is not
                    possible to that on any input stream, but if you know the document URI, you can
                    open the streaming document multiple times using the <code>xsl:stream</code>
                    instruction.</para>
            </section>
            <section>
                <title>Applicability</title>
                <section>
                    <title>Applies to</title>
                    <para>This pattern applies to the following scenarios:<orderedlist>
                            <listitem>
                                <para>Any expression requiring precalculation or preprocessing the
                                    input stream.</para>
                            </listitem>
                            <listitem>
                                <para>Expressions that cannot be split with forking.</para>
                            </listitem>
                            <listitem>
                                <para>Expressions that cannot use windowed streaming, for instance,
                                    that rely on the whole document.</para>
                            </listitem>
                        </orderedlist></para>
                </section>
                <section>
                    <title>Does not apply to</title>
                    <para>This pattern does not apply to:<orderedlist>
                            <listitem>
                                <para>Streaming documents that are not restartable<footnote>
                                        <para>Sometimes an input document can only be processed
                                                <emphasis role="italic">on the fly</emphasis>, like
                                            a Twitter or news feed, a volatile memory stream or a
                                            listener to a network socket stream. Such streams cannot
                                            be restarted.</para>
                                    </footnote>.</para>
                            </listitem>
                            <listitem>
                                <para>Streaming documents that do not have an accessible URI.</para>
                            </listitem>
                        </orderedlist></para>
                </section>
            </section>
            <section>
                <title>Consequences</title>
                <para>Applying this pattern has the following consequences:<orderedlist>
                        <listitem>
                            <para>Going twice or more over a large input document using streaming
                                will increase the processing time by a factor of two or more.</para>
                        </listitem>
                        <listitem>
                            <para>Reliance on the document URI may have security
                                implications.</para>
                        </listitem>
                    </orderedlist></para>
            </section>
            <section>
                <title>Implementation</title>
                <para>Refactor your original code by applying the following steps in order:<orderedlist>
                        <listitem>
                            <para>Introduce a streaming mode.</para>
                        </listitem>
                        <listitem>
                            <para>Create a global variable to hold the initial input document
                                URI.</para>
                        </listitem>
                        <listitem>
                            <para>Create a global variable for preprocessing the stream.</para>
                        </listitem>
                        <listitem>
                            <para>Apply previous patterns to make the stylesheet streamable.</para>
                        </listitem>
                        <listitem>
                            <para>Replace the free-ranging expressions with a variable
                                reference.</para>
                        </listitem>
                    </orderedlist></para>
                <section>
                    <title>Example</title>
                    <para>Applying these five refactoring rules to our original example, we end up
                        with the following code:
                        <programlisting>&lt;!-- (1) introduce a streamable mode --&gt;
&lt;xsl:mode streamable="yes" /&gt;

&lt;!-- (2) capture the initial doc uri --&gt;
&lt;xsl:variable name="docuri"
    select="base-uri(.)" /&gt;

&lt;!-- (3) preprocess the total --&gt;
&lt;xsl:variable name="total"&gt;
  &lt;xsl:stream href="{$docuri}"&gt;
    &lt;xsl:value-of
      select="sum(//text()[parent::amount])" /&gt;
  &lt;/xsl:stream&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="node() | @*"&gt;
  &lt;xsl:copy&gt;
    &lt;!-- (4) apply streamability refactoring --&gt;
    &lt;xsl:apply-templates select="@*" /&gt;
    &lt;xsl:apply-templates select="node()" /&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="/expenses"&gt;
  &lt;xsl:copy&gt;
    &lt;!-- (4) apply streamability refactoring --&gt;
    &lt;xsl:apply-templates select="@*" /&gt;
    &lt;xsl:apply-templates select="node()" /&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="data"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:attribute name="total" select="$total" /&gt;

    &lt;!-- (4) apply streamability
             refactoring: forking --&gt;
    &lt;xsl:fork&gt;
      &lt;xsl:sequence&gt;
        &lt;!-- (5) use the precalculated $total --&gt;
        &lt;xsl:attribute name="perc"
          select="round(sum(amount) div
                  $total * 100)" /&gt;                    
      &lt;/xsl:sequence&gt;
      &lt;xsl:sequence&gt;
        &lt;!-- (4) apply streamability
                 refactoring --&gt;
        &lt;xsl:apply-templates select="@*" /&gt;
        &lt;xsl:apply-templates select="node()" /&gt;                    
      &lt;/xsl:sequence&gt;
    &lt;/xsl:fork&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</programlisting></para>
                    <para>The example necessarily relies on previous streaming patterns, namely
                        forking and splitting the identity select expression <code>node() |
                            @*</code> into two; see previous sections for how these refactorings
                        work.</para>
                    <para>The new streaming pattern introduced here is preprocessing the stream, or
                        in other words, multi-pass streaming. There are no constructs in XSLT 3.0
                        that specifically facilitate multi-pass streaming, but using this pattern,
                        it is relatively straightforward to do.</para>
                    <para>The variable <code>$docuri</code> relies on the global dynamic context. It
                        is not allowed with streaming to consume a streamed node in a global
                        variable, but it is allowed to use a motionless expression, in this case
                            <code>base-uri(.)</code>, which stores the URI of the input document<footnote>
                            <para>The rules on accessing the global context node in a streaming
                                context is still under debate in the working group. It is possible
                                that support for this will be dropped, in which case you should use
                                a parameter instead and pass the document URI on through the
                                infrastructure of your processor.</para>
                        </footnote>.</para>
                    <para>The second variable, <code>$total</code>, uses the <code>xsl:stream</code>
                        instruction and the URI of the initial input document from
                            <code>$docuri</code> to process the whole stream. Depending on the size
                        of your stream, this can be a lengthy operation, but because variables are
                        stable and deterministic in XSLT, this will be done only once. </para>
                    <para>The expression inside <code>fn:sum</code> may require a little
                        explanation. The easier thing to do would be to write <code>//amount</code>
                        as in the original non-streaming example. However, because of the chance of
                        overlapping nodes, such an expression is not streamable within this
                        function. This limitation may be lifted in streamability analysis, in fact
                        there is a strong sentiment in the Working Group to allow such constructs
                        and to allow limited buffering by processors, but at the time of this
                        writing, there was no decision yet. We have seen before that childless nodes
                        do not suffer the same problem (there is no chance for overlap), hence we
                        can rewrite the expression to focus on the the text nodes as
                            <code>text()[parent::amount]</code>, which is streamable.</para>
                    <para>After defining a global variable for preprocessing the input stream, it
                        becomes relatively trivial to rewrite the rest of the stylesheet to use this
                        variable and to introduce forking for the part that still have multiple
                        downward selects.</para>
                    <para>Note: processing a streaming document is by definition not stable, because
                        the document will not be held in memory. That means, if during streaming the
                        document's content changes, this will effect the outcome of the
                        transformation. Going over the document twice, as in this streaming pattern,
                        has the same potential side-effect: the document may change between
                        processing through the <code>xsl:stream</code> instruction and the initial
                        input tree processing in the streaming mode. It is up to the document
                        provider to make sure that the document remains stable for the duration of
                        the processing.</para>
                </section>
            </section>
        </section>
        <section xml:id="paper-25_call_template">
            <title>Dependencies on xsl:call-template</title>
            <section>
                <title>Intent</title>
                <para>You have a stylesheet with dependencies on <code>xsl:call-template</code> and
                    want to make it streamable.</para>
            </section>
            <section>
                <title>Level</title>
                <para>Intermediate, sometimes requires forking. Streamability level: full.</para>
            </section>
            <section>
                <title>Motivation</title>
                <para>Consider the following
                    example:<programlisting>&lt;xsl:template match="person"&gt;
  &lt;xsl:call-template name="address"&gt;
    &lt;xsl:with-param name="street"
                    select="address/street" /&gt;
    &lt;xsl:with-param name="number"
                    select="address/number" /&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="address"&gt;
  &lt;xsl:param name="street" /&gt;
  &lt;xsl:param name="number" /&gt;
  &lt;xsl:value-of select="$number, $street" /&gt;
&lt;/xsl:template&gt;</programlisting></para>
                <para>The instruction <code>xsl:call-template</code> is severely limited when used
                    with streaming. You cannot pass references to nodes and you cannot use the
                    context item. If there is an implicit context item as in the example above,
                    streamability analysis will fail. </para>
            </section>
            <section>
                <title>Applicability</title>
                <section>
                    <title>Applies to</title>
                    <para>This pattern applies to the following scenarios:<orderedlist>
                            <listitem>
                                <para>Any use of <code>xsl:call-template</code> involving streamed
                                    nodes.</para>
                            </listitem>
                            <listitem>
                                <para>Any other <code>xsl:call-template</code>, unless the context
                                    item is explicitly prohibited.</para>
                            </listitem>
                        </orderedlist></para>
                </section>
                <section>
                    <title>Does not apply to</title>
                    <para>This pattern does not apply to:<orderedlist>
                            <listitem>
                                <para>Other instructions than <code>xsl:call-template</code>.</para>
                            </listitem>
                        </orderedlist></para>
                </section>
            </section>
            <section>
                <title>Consequences</title>
                <para>Applying this pattern has the following consequences:<orderedlist>
                        <listitem>
                            <para>Your programmers will have to learn not to use
                                    <code>xsl:call-template</code> in streaming scenarios.</para>
                        </listitem>
                    </orderedlist></para>
            </section>
            <section>
                <title>Implementation</title>
                <para>There are no existing situations that I know of that actually <emphasis role="italic">require</emphasis> the use of <code>xsl:call-template</code>.
                    The streaming pattern proposed here is to get rid of it. However, there is one
                    scenario where this is not necessary, which is when the called template is not
                    dependent on the context item and the parameters are motionless expressions. In
                    such cases, simply add a <code>&lt;xsl:context-item use="prohibited"/&gt;</code><footnote>
                        <para>The instruction <code>xsl:context-item</code> is new in XSLT 3.0 and
                            determines the type of the expected context item and whether or not
                            there should be a context item at all. Using
                                <code>use="prohibited"</code> prohibits a context item, which, in
                            the case of <code>xsl:call-template</code> means that the context item
                            will not be passed on to the template, it will be absent.</para>
                    </footnote> to the called template.</para>
                <para>If there is dependency on streaming nodes, refactor your original code by
                    applying the following steps in order:<orderedlist>
                        <listitem>
                            <para>Introduce a streaming mode.</para>
                        </listitem>
                        <listitem>
                            <para>Replace the <code>xsl:call-template</code> instructions with
                                either an <code>apply-templates</code> (possibly in another named,
                                but streamable, mode) or a stylesheet function call.</para>
                        </listitem>
                        <listitem>
                            <para>Remove dependencies on streaming nodes in parameters.</para>
                        </listitem>
                        <listitem>
                            <para>Apply other patterns where necessary to make the result
                                streamable.</para>
                        </listitem>
                    </orderedlist></para>
                <section>
                    <title>Example</title>
                    <para>Applying these four refactoring rules to our original example, we end up
                        with the following code:
                        <programlisting>&lt;!-- (1) change the mode to streamable --&gt;
&lt;xsl:mode streamable="yes" /&gt;

&lt;xsl:template match="person"&gt;
  &lt;!-- (2) replace call-template
           with apply-template --&gt;
  &lt;xsl:apply-templates name="address" /&gt;
&lt;/xsl:template&gt;

&lt;!-- (2) replace named template --&gt;
&lt;!-- (3) remove parameters --&gt;
&lt;xsl:template match="address"&gt;
  &lt;xsl:fork&gt;
    &lt;!-- (4) apply other
             patterns, here: forking --&gt;
    &lt;xsl:sequence select="string(number) || ' '" /&gt;
    &lt;xsl:sequence select="string(street)" /&gt;
  &lt;/xsl:fork&gt;
&lt;/xsl:template&gt;</programlisting></para>
                    <para>In most cases, removing dependencies on <code>xsl:call-template</code>
                        will be rather trivial and only requires using known XSLT 2.0 constructs. In
                        this example, we had two downward expressions (potentially) not in document
                        order, which forced us to use forking as explained in an earlier streaming
                        pattern. Other than basic refactoring to get rid of the named template,
                        there are no new concepts revealed here.</para>
                </section>
            </section>
        </section>
        <section xml:id="paper-25_streamable_functions">
            <title>Using streamable stylesheet functions</title>
            <section>
                <title>Intent</title>
                <para>You have a stylesheet function with arguments taking nodes and you want to
                    make it streamable.</para>
            </section>
            <section>
                <title>Level</title>
                <para>Advanced, requires understanding writing streamable functions. Streamability
                    level: full.</para>
            </section>
            <section>
                <title>Motivation</title>
                <para>Consider the following
                    example:<programlisting>&lt;xsl:template match="price"&gt;
  &lt;xsl:value-of select="f:vat(.)" /&gt;
&lt;/xsl:template&gt;

&lt;xsl:function name="f:vat"&gt;
  &lt;xsl:param name="price" /&gt;
  &lt;xsl:value-of select="($price div 121) * 21)" /&gt;
&lt;/xsl:function&gt;</programlisting></para>
                <para>It shows a simple function that takes a <code>price</code> element and
                    calculates the VAT from a VAT-inclusive price, here 21%. </para>
            </section>
            <section>
                <title>Applicability</title>
                <section>
                    <title>Applies to</title>
                    <para>This pattern applies to the following scenarios:<orderedlist>
                            <listitem>
                                <para>Stylesheet functions that have at most one parameter that can
                                    be a node.</para>
                            </listitem>
                            <listitem>
                                <para>Stylesheet functions returning streamed nodes.</para>
                            </listitem>
                        </orderedlist></para>
                </section>
                <section>
                    <title>Does not apply to</title>
                    <para>This pattern does not apply to:<orderedlist>
                            <listitem>
                                <para>Stylesheet functions that take more than one parameter that
                                    can be node<footnote>
                                        <para>The brand new feature that allows functions to take
                                            streamable nodes allows them to have at most one
                                            parameter that is a streamable node. This is defined in
                                            the signature of the function.</para>
                                    </footnote>.</para>
                            </listitem>
                            <listitem>
                                <para>Recursive stylesheet functions<footnote>
                                        <para>It is possible to write functions that are recursive
                                            and guaranteed streamable, but it is a very advanced
                                            concept, very new and likely to change, and out of the
                                            scope of this paper.</para>
                                    </footnote>.</para>
                            </listitem>
                            <listitem>
                                <para>Non-final stylesheet functions<footnote>
                                        <para>In XSLT 3.0 it is possible to use packages (declared
                                            with <code>xsl:package</code>) and to override modes,
                                            named templates and functions, as long as they are
                                            marked overridable. It is currently not allowed to use
                                            streamable functions that are not final, you must either
                                            override a non-final function and make it final, or you
                                            must change the function signature to be final.</para>
                                    </footnote>.</para>
                            </listitem>
                        </orderedlist></para>
                </section>
            </section>
            <section>
                <title>Consequences</title>
                <para>Applying this pattern has the following consequences:<orderedlist>
                        <listitem>
                            <para>All your stylesheet functions signatures will be typed.</para>
                        </listitem>
                        <listitem>
                            <para>Streamable stylesheet function bodies will need to be and remain
                                at most consuming (one downward select, see <xref linkend="paper-25_rule1"/>), which has consequences on maintainability.</para>
                        </listitem>
                    </orderedlist></para>
            </section>
            <section>
                <title>Implementation</title>
                <para>Refactor your original code by applying the following steps in order:<orderedlist>
                        <listitem>
                            <para>Mark the stylesheet function as streamable (if you have not
                                already done so, introduce a streamable mode as well).</para>
                        </listitem>
                        <listitem>
                            <para>Type the return type and the function parameters.</para>
                        </listitem>
                        <listitem>
                            <para>Change the function body to be streamable using other streamable
                                patterns.</para>
                        </listitem>
                    </orderedlist></para>
                <section>
                    <title>Example</title>
                    <para>Applying these three refactoring rules to our original example, we end up
                        with the following code:
                        <programlisting>&lt;!-- (1) introduce a streamable mode --&gt;
&lt;xsl:mode streamable="yes" /&gt;

&lt;xsl:template match="price"&gt;
  &lt;xsl:value-of select="f:vat(.)" /&gt;
&lt;/xsl:template&gt;

&lt;!-- (2) type the function's return type --&gt;
&lt;xsl:function name="f:vat" as="xs:string"&gt;
  &lt;!-- (2) type the function's parameters --&gt;
  &lt;xsl:param name="price" as="element()" /&gt;

  &lt;!-- (3) make body streamable,
           here: nothing to do --&gt;
  &lt;xsl:value-of select="($price div 121) * 21)" /&gt;
&lt;/xsl:function&gt;</programlisting></para>
                    <para>An important step here is to type the parameters and the return type. It
                        is allowed and possible to create streamable functions without it, but it is
                        much harder to write streamable functions that way. By telling the processor
                        that the return type is an atomic type, it can analyse that the function
                        will consume the input node and it can mark calling the stylesheet function
                        with <emphasis role="italic">usage absorption</emphasis>. </para>
                    <para>Inside the function's body, we have an atomizing construct: the variable
                        reference <code>$price</code>, which is bound to a potentially streaming
                        node, will be atomized before division takes place. Atomization always means
                        that the node is going to be consumed. Function declarations follow the same
                        rules as templates,  <xref linkend="paper-25_rule1"/>. However, within functions, the
                        bound parameter is the streaming node for the sake of the analysis. In other
                        words, the call on the <code>$price</code> parameter is now the replacement
                        for the downward select (you could mentally replace it with a node
                        reference, such as the <code>self::price</code> select expression to see how
                        it works).</para>
                    <para>Streamable stylesheet functions are a very recent addition to the
                        machinery available to authors of streamable stylesheets and packages. It is
                        a very powerful one, but it is also one of the most complex to write
                        correctly. It is the only user-defined way of writing a construct that
                        returns nodes which is allowed (recall that named templates cannot operate
                        on streaming nodes at all and that templates are always grounded, meaning
                        that they can never return nodes). </para>
                    <para>For instance, it is possible to write a function that returns the third
                        child based on a certain pattern. The returned node will still be a
                        streaming node and not, as with other constructs, a copy of a
                        node:<programlisting>&lt;xsl:function name="f:child"
              streamable="yes" 
              as="element()"&gt;

  &lt;xsl:param name="node" as="element()" /&gt;
  &lt;xsl:sequence
    select="$node/person[@gender = 'M'][3]" /&gt;
&lt;/xsl:function&gt;</programlisting></para>
                    <para>If you call that function with a streamable expression, you can apply path
                        expressions on the returned value and you will operate on the original node,
                        not a copy of the node. Besides from not requiring the overhead of copied
                        nodes, it has the advantage that the identity of the nodes is preserved. An
                        example of a valid expression is: <code>member/f:child(.)/age</code>.</para>
                </section>
            </section>
        </section>
        <section xml:id="paper-25_sec_sorting">
            <title>Sorting</title>
            <section>
                <title>Intent</title>
                <para>You have a stylesheet construct that requires sorting and you want to make it
                    streamable.</para>
            </section>
            <section>
                <title>Level</title>
                <para>Advanced, requires two-phase streaming, streamable grouping and streamable
                    merging. Streamability level: none<footnote>
                        <para>Sorting itself is not streamable at all. The solution provided for the
                            streamable design pattern is to split the source document into
                            manageable chunks, sort those chunks and then process those again using
                            streamed merging.</para>
                    </footnote> and then: implicitly windowed.</para>
            </section>
            <section>
                <title>Motivation</title>
                <para>Consider the following
                    example:<programlisting>&lt;xsl:template match="log-entry"&gt;
  &lt;xsl:copy-of select="." /&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="/log"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="log-entry" &gt;
      &lt;xsl:sort select="@date" /&gt;
    &lt;/xsl:apply-templates&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</programlisting></para>
                <para>It takes an unsorted log document and sorts it by date. The input could, for
                    instance, look something like the
                    following:<programlisting language="xml">&lt;log&gt;
  &lt;log-entry
    date="2014-05-10"&gt;Some log text&lt;/log-entry&gt;
  &lt;log-entry
    date="2014-05-07"&gt;Some log text&lt;/log-entry&gt;
  &lt;log-entry
    date="2014-05-06"&gt;Some log text&lt;/log-entry&gt;
  &lt;log-entry
    date="2014-05-06"&gt;Some log text&lt;/log-entry&gt;
  &lt;log-entry
    date="2014-05-04"&gt;Some log text&lt;/log-entry&gt;
  &lt;log-entry
    date="2014-05-07"&gt;Some log text&lt;/log-entry&gt;
  &lt;log-entry
    date="2014-05-07"&gt;Some log text&lt;/log-entry&gt;
  &lt;log-entry
    date="2014-05-07"&gt;Some log text&lt;/log-entry&gt;
  &lt;log-entry
    date="2014-05-02"&gt;Some log text&lt;/log-entry&gt;
  &lt;log-entry
    date="2014-05-09"&gt;Some log text&lt;/log-entry&gt;
&lt;/log&gt;</programlisting></para>
            </section>
            <section>
                <title>Applicability</title>
                <section>
                    <title>Applies to</title>
                    <para>This pattern applies to the following scenarios:<orderedlist>
                            <listitem>
                                <para>Any construct using sorting.</para>
                            </listitem>
                        </orderedlist></para>
                </section>
                <section>
                    <title>Does not apply to</title>
                    <para>This pattern does not apply to:<orderedlist>
                            <listitem>
                                <para>Sorting where the sortable items easily fit in memory, in such
                                    scenarios, use a copy of the nodes and apply the sorting to this
                                    copy.</para>
                            </listitem>
                        </orderedlist></para>
                </section>
            </section>
            <section>
                <title>Consequences</title>
                <para>Applying this pattern has the following consequences:<orderedlist>
                        <listitem>
                            <para>Changes the infrastructure for multiple processing, you should
                                consider adding <xref linkend="paper-25_XProc"/> to the toolchain.</para>
                        </listitem>
                        <listitem>
                            <para>The sorting itself will not be obvious in either of the
                                stylesheets.</para>
                        </listitem>
                        <listitem>
                            <para>Requires temporary disk space, equal to the size of the input
                                document, to store the intermediate results.</para>
                        </listitem>
                    </orderedlist></para>
            </section>
            <section>
                <title>Implementation</title>
                <para>Refactor your original code by applying the following steps in order:<orderedlist>
                        <listitem>
                            <para>Introduce a streamable mode in the original stylesheet.</para>
                        </listitem>
                        <listitem>
                            <para>Use streamable grouping to create chunks of the input data, use
                                    <code>group-adjacent</code>.</para>
                        </listitem>
                        <listitem>
                            <para>Use <code>xsl:result-document</code> to write each groups to
                                disk.</para>
                        </listitem>
                        <listitem>
                            <para>Create a copy of each chunk and apply the sorting on the copy,
                                this part need not be streamable<footnote>
                                    <para>As with other streamable design patterns, there are no
                                        limitations on expressions applied to copies of
                                        nodes.</para>
                                </footnote>.</para>
                        </listitem>
                        <listitem>
                            <para>Apply any necessary refactoring to make the rest of the stylesheet
                                streamable.</para>
                        </listitem>
                        <listitem>
                            <para>For phase two, create another streamable stylesheet</para>
                        </listitem>
                        <listitem>
                            <para>Get a collection of the URIs from the documents created in step
                                3.</para>
                        </listitem>
                        <listitem>
                            <para>Add streamable <code>xsl:merge</code> instruction to process this
                                collection.</para>
                        </listitem>
                    </orderedlist></para>
                <section>
                    <title>Example</title>
                    <para>Applying these eight refactoring rules to our original example, we end up
                        with two stylesheets, the first, which creates the smaller sorted chunks of
                        the input document, looks as follows:
                        <programlisting>&lt;!-- (1) introduce a streamable mode --&gt;
&lt;xsl:mode streamable="yes" /&gt;

&lt;!-- (5) other refactoring, here: nothing to do --&gt;
&lt;xsl:template match="log-entry"&gt;
  &lt;xsl:copy-of select="." /&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="/log"&gt;
  &lt;!-- (2) use streamable grouping --&gt;
  &lt;xsl:for-each-group 
    select="log-entry" 
    group-adjacent="position() idiv 3"&gt;

    &lt;!-- (3) write chunks to disk --&gt;
    &lt;xsl:result-document
      href="sorted_{current-grouping-key()}.xml"&gt;
      &lt;log&gt;
        &lt;!-- (4) create copy of each chunk --&gt;
        &lt;xsl:variable name="copy" as="element()*"
           select="copy-of(current-group())"/&gt;

        &lt;!-- (4) and apply sorting on the copy --&gt;
        &lt;xsl:apply-templates select="$copy"&gt;
          &lt;xsl:sort select="@date" /&gt;
        &lt;/xsl:apply-templates&gt;
      &lt;/log&gt;
    &lt;/xsl:result-document&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;</programlisting></para>
                    <para>Most of the rewriting here follows streaming design patterns seen in
                        previous sections. Some parts warrant extra attention:</para>
                    <para>Using <code>group-adjacent</code> is allowed in streamable scenarios as
                        long as the expression is motionless. Using <code>fn:position</code> is
                        motionless, and so is any calculation on it. With <code>idiv</code> we get
                        nice round numbers for our splitting. The size for our chunks here is 500,
                        but any number can be used as long as the chunks by themselves fit in
                        memory.</para>
                    <para>A copy of each group is created using <code>fn:copy-of</code>, and stored
                        in a variable. Instead of storing it in a variable, you can inline this in
                        the apply-templates instruction<footnote>
                            <para>Some versions of Saxon did not allow multiple nodes as argument to
                                    <code>fn:copy-of</code>, however, the specification does allow
                                this.</para>
                        </footnote>.</para>
                    <para>Finally, applying templates on this copy and sorting them using
                            <code>xsl:sort</code> is allowed, because the nodes are not streamed
                        anymore, they are a copy. The streaming design pattern so far, without the
                            <code>xsl:result-document</code> and the grouping, can serve as a
                        solution if the nodes to be sorted fit in memory.</para>
                    <para>The stylesheet for the second phase looks as
                        follows:<programlisting>&lt;!-- (6) 2nd pass streamable stylesheet --&gt;
&lt;xsl:mode streamable="yes" /&gt;

&lt;xsl:template match="/log"&gt;
  &lt;xsl:copy&gt;
    &lt;!-- (7) collection of uris,
             see your proc's documentation --&gt;
    &lt;xsl:variable name="uricoll" 
      select="'uri-collection('sorted-chunks')" /&gt;

    &lt;!-- (8) merge sorted output from 1st phase --&gt;
    &lt;xsl:merge&gt;
      &lt;xsl:merge-source 
        for-each-stream="$uricoll"
        select="log/log-entry"&gt;
          &lt;xsl:merge-key select="@date" /&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
        &lt;xsl:copy-of
          select="current-merge-group()"/&gt;
      &lt;/xsl:merge-action&gt;
    &lt;/xsl:merge&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</programlisting></para>
                    <para>An <code>xsl:merge</code> instruction takes one or more input documents
                        and merges them based on a merge-key, similar to the way sorting works. It
                        processes the input documents one item at the time, based on the
                        select-statement in the <code>xsl:merge-source</code> instruction. In the
                        case of streaming, it does so in order, which is why the input documents
                        must be pre-sorted. It will output the elements in the order defined by the
                        merge-key, inserting the elements from the other source documents where
                        necessary, to preserve order.</para>
                    <para>The input for <code>xsl:merge-source</code> is given by the
                            <code>for-each-stream</code> attribute, which takes a sequence of
                        strings that must be valid URI's. In the above example, I use
                            <code>fn:uri-collection</code>, which works like
                            <code>fn:collection</code>, but instead of returning a sequence of
                        document nodes, it will return a sequence of URI's. The way a collection URI
                        is interpreted is implementation dependent, which is why in the above
                        example I wrote "see the processor's documentation". Most implementations
                        will support a kind of wildcard matching and the usage of some form of XML
                        catalogs.</para>
                    <para>The <code>xsl:merge-action</code> defines the action to occur upon each
                        merge operation. There will be one action for each unique merge-key. If
                        multiple elements have the same key, they are added to the current merge
                        group, which can be requested, similar as with grouping, using
                            <code>fn:current-merge-group</code>. The current merge group is
                        implicitly grounded and maintains access to its ancestors similar to a call
                        to <code>fn:snapshot</code>. This has the advantage that you can use
                        free-ranging expressions on the merge group.</para>
                    <para>In our scenario, no additional processing has to take place. We simply
                        want all the <code>log-entry</code> elements merged back into one big
                        document. The result is a sorted document.</para>
                    <para>This method of sorting, using splitting, sorting on small chunks and then
                        merging back is the simplest way to do sorting in a streaming way. It is
                        also the only way to do streamable sorting that requires only two phases. A
                        single phase streaming sort is not possible.</para>
                </section>
            </section>
        </section>
    </section>
    <section xmlns:xl="http://www.w3.org/1999/xlink" xml:id="paper-25_streamable_packages">
        <title>Streamable packages</title>
        <para>With XSLT 3.0 a new feature called <emphasis role="italic">packaging</emphasis> has
            been introduced. Packaging allows authors to create libraries of stylesheet functions,
            stylesheet templates and other stylesheet declarations that can be precompiled,
            distributed and used as a library of functions with other stylesheets. It extends the
            ways <code>xsl:import</code> works, it allows a certain level of overridability similar
            to object-oriented languages and it supports information hiding through private and
            public named declarations.</para>
        <para>Package authors that wish to reach a largest as possible audience for their library
            packages, would want to prepare their packages to behave properly in streaming
            scenarios. Since non-streaming scenarios can safely ignore the streamability properties,
            it is suggested that package authors strive to write their packages, the public
            stylesheet functions and public modes with streamability in mind.</para>
        <para>It is not possible to create a public mode to be both streamable and non-streamable.
            But it is possible to create two modes, one streamable and one not, that is processed by
            the same streamable templates that each have their mode set to <code>#all</code> or at
            least to both modes.</para>
        <para>For stylesheet functions, they can safely have the <code>streamable</code> attribute
            set to <code>yes</code> if they take nodes as parameters. A non-streamable usage of a
            streamable function behaves without side effects exactly the same as in a streamable
            context. If package authors choose to write defensively and write each function
            according to the guaranteed streamability rules, their packages can be used
            cross-processor and with both streamable and non-streamable input.</para>
    </section>
    <section xmlns:xl="http://www.w3.org/1999/xlink" xml:id="paper-25_conclusion">
        <title>Conclusion</title>
        <para>Many common classical XSLT programming scenarios and patterns appear to be convertible
            into guaranteed streamable code with relative ease. Following ten easy-to-remember
            rules, with on top of the list the rule on having a maximum of one downward expression
            per context or template brings us closer to a fully streamable stylesheet. Taking
            original programming patterns and seeing how they change into streamable programming
            patterns should give the intermediate to advanced XSLT programmer, or the beginning
            Streaming XSLT programmer a good starting point.</para>
        <para>Some more complex scenarios including forking, streamable grouping, merging and even
            sorting were covered, showing that the current state of the specification, including the
            fixes available through BugZilla, work with a wide range of potential streaming
            use-cases.</para>
        <para>Streaming is not hard, you just need to set your mind to it, and once set, adjusting
            your code to process large, even huge documents, becomes almost a breeze.</para>
    </section>

    <bibliography xmlns:xl="http://www.w3.org/1999/xlink">
        <title>Bibliography</title>
            <biblioentry xml:id="paper-25_BRA14" xreflabel="[BRA14]">
                <abbrev>BRA14</abbrev>
                <citetitle>Streaming for the masses</citetitle>
                <biblioid class="uri">http://archive.xmlprague.cz/2014/files/xmlprague-2014-proceedings.pdf#page=43</biblioid>
                <pubdate>2014</pubdate>
                <authorgroup>
                    <editor>
                        <personname>
                            <firstname>Abel</firstname>
                            <surname>Braaksma</surname>
                        </personname>
                    </editor>
                </authorgroup>
            </biblioentry>
            <biblioentry xml:id="paper-25_BUGZ" xreflabel="[BUGZ]">
                <abbrev>BUGZ</abbrev>
                <citetitle>Bugzilla - Public W3C Bug / Issue tracking system</citetitle>
                <biblioid class="uri">https://www.w3.org/Bugs/Public/</biblioid>
                <pubdate>2014</pubdate>
                <authorgroup>
                    <editor>
                        <personname>
                            <firstname>Miscelleneous</firstname>
                            <surname>authors</surname>
                        </personname>
                    </editor>
                </authorgroup>
            </biblioentry>
            <biblioentry xml:id="paper-25_FO3" xreflabel="[FO3]">
                <abbrev>FO3</abbrev>
                <citetitle>XPath and XQuery Functions and Operators 3.0, latest version</citetitle>
                <biblioid class="uri">http://www.w3.org/TR/xpath-functions-30/</biblioid>
                <pubdate>2014</pubdate>
                <authorgroup>
                    <editor>
                        <personname>
                            <firstname>Michael</firstname>
                            <surname>Kay</surname>
                        </personname>
                    </editor>
                </authorgroup>
            </biblioentry>
            <biblioentry xml:id="paper-25_FOPR" xreflabel="[FOPR]">
                <abbrev>FOPR</abbrev>
                <citetitle>XPath and XQuery Functions and Operators 3.0, W3C Proposed Recommendation 22 October 2013</citetitle>
                <biblioid class="uri">http://www.w3.org/TR/2013/PR-xpath-functions-30-20131022/</biblioid>
                <pubdate>2013</pubdate>
                <authorgroup>
                    <editor>
                        <personname>
                            <firstname>Michael</firstname>
                            <surname>Kay</surname>
                        </personname>
                    </editor>
                </authorgroup>
            </biblioentry>
            <biblioentry xml:id="paper-25_MKAY08" xreflabel="[MKAY08]">
                <abbrev>MKAY08</abbrev>
                <citetitle>XSLT 2.0 and XPath 2.0 Programmer's Reference</citetitle>
                <edition>4th edition</edition>
                <pubdate>2008</pubdate>
                <authorgroup>
                    <editor>
                        <personname>
                            <firstname>Michael</firstname>
                            <surname>Kay</surname>
                        </personname>
                    </editor>
                </authorgroup>
            </biblioentry>
            <biblioentry xml:id="paper-25_XDM" xreflabel="[XDM]">
                <abbrev>XDM</abbrev>
                <citetitle>XQuery and XPath Data Model 3.0, latest version</citetitle>
                <biblioid class="uri">http://www.w3.org/TR/xpath-datamodel-30/</biblioid>
                <pubdate>2014</pubdate>
                <authorgroup>
                    <editor>
                        <personname>
                            <firstname>Norman</firstname>
                            <surname>Walsh</surname>
                        </personname>
                    </editor>
                    <editor>
                        <personname>
                            <firstname>Anders</firstname>
                            <surname>Berglund</surname>
                        </personname>
                    </editor>
                    <editor>
                        <personname>
                            <firstname>John</firstname>
                            <surname>Snelson</surname>
                        </personname>
                    </editor>
                </authorgroup>
            </biblioentry>
            <biblioentry xml:id="paper-25_XP3" xreflabel="[XP3]">
                <abbrev>XP3</abbrev>
                <citetitle>XML Path Language (XPath) 3.0, Latest Version</citetitle>
                <biblioid class="uri">http://www.w3.org/TR/xpath-30/</biblioid>
                <pubdate>2014</pubdate>
                <authorgroup>
                    <editor>
                        <personname>
                            <firstname>Jonathan</firstname>
                            <surname>Robie</surname>
                        </personname>
                    </editor>
                    <editor>
                        <personname>
                            <firstname>Don</firstname>
                            <surname>Chamberlin</surname>
                        </personname>
                    </editor>
                    <editor>
                        <personname>
                            <firstname>Michael</firstname>
                            <surname>Dyck</surname>
                        </personname>
                    </editor>
                    <editor>
                        <personname>
                            <firstname>John</firstname>
                            <surname>Snelson</surname>
                        </personname>
                    </editor>
                </authorgroup>
            </biblioentry>
            <biblioentry xml:id="paper-25_XPPR" xreflabel="[XPPR]">
                <abbrev>XPPR</abbrev>
                <citetitle>XML Path Language (XPath) 3.0, W3C Proposed Recommendation 08 January
                    2013</citetitle>
                <biblioid class="uri">http://www.w3.org/TR/2013/CR-xpath-30-20130108/</biblioid>
                <pubdate>2013</pubdate>
                <authorgroup>
                    <editor>
                        <personname>
                            <firstname>Jonathan</firstname>
                            <surname>Robie</surname>
                        </personname>
                    </editor>
                    <editor>
                        <personname>
                            <firstname>Don</firstname>
                            <surname>Chamberlin</surname>
                        </personname>
                    </editor>
                    <editor>
                        <personname>
                            <firstname>Michael</firstname>
                            <surname>Dyck</surname>
                        </personname>
                    </editor>
                    <editor>
                        <personname>
                            <firstname>John</firstname>
                            <surname>Snelson</surname>
                        </personname>
                    </editor>
                </authorgroup>
            </biblioentry>
            <biblioentry xml:id="paper-25_XProc" xreflabel="[XProc]">
                <abbrev>XProc</abbrev>
                <citetitle>X\XProc: An XML Pipeline Language, W3C Recommendation 11 May 2010</citetitle>
                <biblioid class="uri">http://www.w3.org/TR/xproc/</biblioid>
                <pubdate>2010</pubdate>
                <authorgroup>
                    <editor>
                        <personname>
                            <firstname>Norman</firstname>
                            <surname>Walsh</surname>
                        </personname>
                    </editor>
                    <editor>
                        <personname>
                            <firstname>Alex</firstname>
                            <surname>Milowski</surname>
                        </personname>
                    </editor>
                    <editor>
                        <personname>
                            <firstname>Henry S.</firstname>
                            <surname>Thompson</surname>
                        </personname>
                    </editor>
                </authorgroup>
            </biblioentry>
            <biblioentry xml:id="paper-25_XSLT3" xreflabel="[XSLT3]">
                <abbrev>XSLT3</abbrev>
                <citetitle>XSL Transformations (XSLT) Version 3.0, Latest Version</citetitle>
                <biblioid class="uri">http://www.w3.org/TR/xslt-30/</biblioid>
                <pubdate>2013</pubdate>
                <editor>
                    <personname>
                        <firstname>Michael</firstname>
                        <surname>Kay</surname>
                    </personname>
                </editor>
            </biblioentry>
            <biblioentry xml:id="paper-25_XSLWD" xreflabel="[XSLWD]">
                <abbrev>XSLWD</abbrev>
                <citetitle>XSL Transformations (XSLT) Version 3.0, W3C Last Call Working Draft 12 December
                    2013</citetitle>
                <biblioid class="uri">http://www.w3.org/TR/2013/WD-xslt-30-20130201/</biblioid>
                <pubdate>2013</pubdate>
                <editor>
                    <personname>
                        <firstname>Michael</firstname>
                        <surname>Kay</surname>
                    </personname>
                </editor>
            </biblioentry>

    </bibliography>

</article>